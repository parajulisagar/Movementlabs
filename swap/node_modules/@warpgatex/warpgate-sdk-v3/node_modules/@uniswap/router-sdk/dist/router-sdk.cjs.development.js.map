{"version":3,"file":"router-sdk.cjs.development.js","sources":["../src/constants.ts","../src/approveAndCall.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/mixedRoute/route.ts","../src/utils/getOutputAmount.ts","../src/entities/mixedRoute/trade.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/utils/encodeMixedRouteToPath.ts","../src/utils/index.ts","../src/swapRouter.ts"],"sourcesContent":["import { Percent } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\n\nexport const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// = 1 << 23 or 100000000000000000000000\nexport const V2_FEE_PATH_PLACEHOLDER = 8388608\n\nexport const ZERO_PERCENT = new Percent(ZERO)\nexport const ONE_HUNDRED_PERCENT = new Percent(100, 100)\n","import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length === 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw new Error('Error: invalid ApprovalType')\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Represents a list of pools or pairs through which a swap can occur\n * @template TInput The input token\n * @template TOutput The output token\n */\nexport class MixedRouteSDK<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: TPool[]\n  public readonly path: Currency[]\n  public readonly input: TInput\n  public readonly output: TOutput\n  public readonly adjustedInput: Currency // routes with v2/v3 initial pool must wrap native input currency before trading\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  /**\n   * Creates an instance of route.\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\n   * @param input The input token\n   * @param output The output token\n   */\n  public constructor(pools: TPool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every((pool) => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    if (pools[0] instanceof V4Pool) {\n      this.adjustedInput = pools[0].involvesToken(input) ? input : input.wrapped\n    } else {\n      this.adjustedInput = input.wrapped // no native currencies in v2/v3\n    }\n\n    invariant(pools[0].involvesToken(this.adjustedInput as Token), 'INPUT')\n    const lastPool = pools[pools.length - 1]\n    if (lastPool instanceof V4Pool) {\n      invariant(lastPool.involvesToken(output) || lastPool.involvesToken(output.wrapped), 'OUTPUT')\n    } else {\n      invariant(lastPool.involvesToken(output.wrapped as Token), 'OUTPUT')\n    }\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Currency[] = [this.adjustedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.path = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price.asFraction),\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price.asFraction),\n            }\n      },\n\n      this.pools[0].token0.equals(this.adjustedInput)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price.asFraction,\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price.asFraction,\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import { Currency, CurrencyAmount } from '@uniswap/sdk-core'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\n\ntype TPool = Pair | V3Pool | V4Pool\n\nexport async function getOutputAmount(\n  pool: TPool,\n  amountIn: CurrencyAmount<Currency>\n): Promise<[CurrencyAmount<Currency>, TPool]> {\n  if (pool instanceof V4Pool) {\n    if (pool.involvesCurrency(amountIn.currency)) {\n      return await pool.getOutputAmount(amountIn)\n    } else if (pool.involvesCurrency(amountIn.currency.wrapped)) {\n      return await pool.getOutputAmount(amountIn.wrapped)\n    }\n  }\n  return await pool.getOutputAmount(amountIn.wrapped)\n}\n","import { Currency, Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { BestTradeOptions, Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../../constants'\nimport { MixedRouteSDK } from './route'\nimport { getOutputAmount } from '../../utils/getOutputAmount'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n * @param a The first trade to compare\n * @param b The second trade to compare\n * @returns A sorted ordering for two neighboring elements in a trade array\n */\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: MixedRouteTrade<TInput, TOutput, TTradeType>,\n  b: MixedRouteTrade<TInput, TOutput, TTradeType>\n) {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      const aHops = a.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      const bHops = b.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      return aHops - bHops\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n/**\n * Represents a trade executed against a set of routes where some percentage of the input is\n * split across each route.\n *\n * Each route has its own set of pools. Pools can not be re-used across routes.\n *\n * Does not account for slippage, i.e., changes in price environment that can occur between\n * the time the trade is submitted and when it is executed.\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n */\nexport class MixedRouteTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\n   * this will return an error.\n   *\n   * When the trade consists of just a single route, this returns the route of the trade,\n   * i.e. which pools the trade goes through.\n   */\n  public get route(): MixedRouteSDK<TInput, TOutput> {\n    invariant(this.swaps.length === 1, 'MULTIPLE_ROUTES')\n    return this.swaps[0].route\n  }\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade.\n   */\n  public readonly swaps: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The cached result of the input amount computation\n   * @private\n   */\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  /**\n   * The cached result of the output amount computation\n   * @private\n   */\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  /**\n   * The cached result of the computed execution price\n   * @private\n   */\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Constructs a trade by simulating swaps through the given route\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param route route to swap through\n   * @param amount the amount specified, either input or output, depending on tradeType\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The route\n   */\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const amounts: CurrencyAmount<Currency>[] = new Array(route.path.length)\n    let inputAmount: CurrencyAmount<TInput>\n    let outputAmount: CurrencyAmount<TOutput>\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n    invariant(amount.currency.equals(route.input), 'INPUT')\n\n    amounts[0] = route.pools[0] instanceof V4Pool ? amount : amount.wrapped\n    for (let i = 0; i < route.path.length - 1; i++) {\n      const pool = route.pools[i]\n      const [outputAmount] = await getOutputAmount(pool, amounts[i])\n      amounts[i + 1] = outputAmount\n    }\n\n    inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n    outputAmount = CurrencyAmount.fromFractionalAmount(\n      route.output,\n      amounts[amounts.length - 1].numerator,\n      amounts[amounts.length - 1].denominator\n    )\n\n    return new MixedRouteTrade({\n      routes: [{ inputAmount, outputAmount, route }],\n      tradeType,\n    })\n  }\n\n  /**\n   * Constructs a trade from routes by simulating swaps\n   *\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param routes the routes to swap through and how much of the amount should be routed through each\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The trade\n   */\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    routes: {\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n      route: MixedRouteSDK<TInput, TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const populatedRoutes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, amount } of routes) {\n      const amounts: CurrencyAmount<Currency>[] = new Array(route.path.length)\n      let inputAmount: CurrencyAmount<TInput>\n      let outputAmount: CurrencyAmount<TOutput>\n\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      amounts[0] = CurrencyAmount.fromFractionalAmount(route.adjustedInput, amount.numerator, amount.denominator)\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pool = route.pools[i]\n        const [outputAmount] = await getOutputAmount(pool, amounts[i])\n        amounts[i + 1] = outputAmount\n      }\n\n      outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        amounts[amounts.length - 1].numerator,\n        amounts[amounts.length - 1].denominator\n      )\n\n      populatedRoutes.push({ route, inputAmount, outputAmount })\n    }\n\n    return new MixedRouteTrade({\n      routes: populatedRoutes,\n      tradeType,\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTrade<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade({\n      ...constructorArguments,\n      routes: [\n        {\n          inputAmount: constructorArguments.inputAmount,\n          outputAmount: constructorArguments.outputAmount,\n          route: constructorArguments.route,\n        },\n      ],\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTradeWithMultipleRoutes<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade(constructorArguments)\n  }\n\n  /**\n   * Construct a trade by passing in the pre-computed property values\n   * @param routes The routes through which the trade occurs\n   * @param tradeType The type of trade, exact input or exact output\n   */\n  private constructor({\n    routes,\n    tradeType,\n  }: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    const inputCurrency = routes[0].inputAmount.currency\n    const outputCurrency = routes[0].outputAmount.currency\n    invariant(\n      routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolIdentifierSet = new Set<string>()\n    for (const { route } of routes) {\n      for (const pool of route.pools) {\n        if (pool instanceof V4Pool) {\n          poolIdentifierSet.add(pool.poolId)\n        } else if (pool instanceof V3Pool) {\n          poolIdentifierSet.add(V3Pool.getAddress(pool.token0, pool.token1, pool.fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolIdentifierSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n\n    invariant(numPools === poolIdentifierSet.size, 'POOLS_DUPLICATED')\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    this.swaps = routes\n    this.tradeType = tradeType\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    /// does not support exactOutput, as enforced in the constructor\n    const slippageAdjustedAmountOut = new Fraction(ONE)\n      .add(slippageTolerance)\n      .invert()\n      .multiply(amountOut.quotient).quotient\n    return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    return amountIn\n    /// does not support exactOutput\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pools the pools to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\n   * @param currentPools used in recursion; the current list of pools\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   * @returns The exact in trade\n   */\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pools: TPool[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPools: TPool[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Promise<MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\n    invariant(pools.length > 0, 'POOLS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn\n    for (let i = 0; i < pools.length; i++) {\n      const pool = pools[i]\n      const amountInAdjusted = pool instanceof V4Pool ? amountIn : amountIn.wrapped\n      // pool irrelevant\n      if (!pool.token0.equals(amountInAdjusted.currency) && !pool.token1.equals(amountInAdjusted.currency)) continue\n      if (pool instanceof Pair) {\n        if ((pool as Pair).reserve0.equalTo(ZERO) || (pool as Pair).reserve1.equalTo(ZERO)) continue\n      }\n\n      let amountOut: CurrencyAmount<Currency>\n      try {\n        ;[amountOut] =\n          pool instanceof V4Pool\n            ? await pool.getOutputAmount(amountInAdjusted)\n            : await pool.getOutputAmount(amountInAdjusted.wrapped)\n      } catch (error) {\n        // input too low\n        // @ts-ignore[2571] error is unknown\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.wrapped.equals(currencyOut.wrapped)) {\n        sortedInsert(\n          bestTrades,\n          await MixedRouteTrade.fromRoute(\n            new MixedRouteSDK([...currentPools, pool], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pools.length > 1) {\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await MixedRouteTrade.bestTradeExactIn(\n          poolsExcludingThisPool,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPools, pool],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n  V4 = 'V4',\n  MIXED = 'MIXED',\n}\n","// entities/route.ts\n\nimport { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Route as V4RouteSDK, Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { MixedRouteSDK } from './mixedRoute/route'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pair | V3Pool | V4Pool> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Currency[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, V3Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n\n// V4 route wrapper\nexport class RouteV4<TInput extends Currency, TOutput extends Currency>\n  extends V4RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, V4Pool>\n{\n  public readonly protocol: Protocol = Protocol.V4\n  public readonly path: Currency[]\n\n  constructor(v4Route: V4RouteSDK<TInput, TOutput>) {\n    super(v4Route.pools, v4Route.input, v4Route.output)\n    this.path = v4Route.currencyPath\n  }\n}\n\n// Mixed route wrapper\nexport class MixedRoute<TInput extends Currency, TOutput extends Currency>\n  extends MixedRouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>\n{\n  public readonly protocol: Protocol = Protocol.MIXED\n\n  constructor(mixedRoute: MixedRouteSDK<TInput, TOutput>) {\n    super(mixedRoute.pools, mixedRoute.input, mixedRoute.output)\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool, Route as V4RouteSDK, Trade as V4TradeSDK } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ONE_HUNDRED_PERCENT, ZERO, ZERO_PERCENT } from '../constants'\nimport { MixedRouteSDK } from './mixedRoute/route'\nimport { MixedRouteTrade as MixedRouteTradeSDK } from './mixedRoute/trade'\nimport { IRoute, MixedRoute, RouteV2, RouteV3, RouteV4 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    v4Routes,\n    tradeType,\n    mixedRoutes,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v4 routes\n    for (const { routev4, inputAmount, outputAmount } of v4Routes) {\n      const route = new RouteV4(routev4)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap mixedRoutes\n    if (mixedRoutes) {\n      for (const { mixedRoute, inputAmount, outputAmount } of mixedRoutes) {\n        const route = new MixedRoute(mixedRoute)\n        this.routes.push(route)\n        this.swaps.push({\n          route,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    if (this.swaps.length === 0) {\n      throw new Error('No routes provided when calling Trade constructor')\n    }\n\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolIdentifierSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (pool instanceof V4Pool) {\n          poolIdentifierSet.add(pool.poolId)\n        } else if (pool instanceof V3Pool) {\n          poolIdentifierSet.add(V3Pool.getAddress(pool.token0, pool.token1, pool.fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolIdentifierSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n    invariant(numPools === poolIdentifierSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * Returns the sell tax of the input token\n   */\n  public get inputTax(): Percent {\n    const inputCurrency = this.inputAmount.currency\n    if (inputCurrency.isNative || !inputCurrency.wrapped.sellFeeBps) return ZERO_PERCENT\n\n    return new Percent(inputCurrency.wrapped.sellFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * Returns the buy tax of the output token\n   */\n  public get outputTax(): Percent {\n    const outputCurrency = this.outputAmount.currency\n    if (outputCurrency.isNative || !outputCurrency.wrapped.buyFeeBps) return ZERO_PERCENT\n\n    return new Percent(outputCurrency.wrapped.buyFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the expected execution price\n   * In order to exclude token taxes from the price impact calculation, the spot price is calculated\n   * using a ratio of values that go into the pools, which are the post-tax input amount and pre-tax output amount.\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    // returns 0% price impact even though this may be inaccurate as a swap may have occured.\n    // because we're unable to derive the pre-buy-tax amount, use 0% as a placeholder.\n    if (this.outputTax.equalTo(ONE_HUNDRED_PERCENT)) return ZERO_PERCENT\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      const postTaxInputAmount = inputAmount.multiply(new Fraction(ONE).subtract(this.inputTax))\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(postTaxInputAmount))\n    }\n\n    // if the total output of this trade is 0, then most likely the post-tax input was also 0, and therefore this swap\n    // does not move the pools' market price\n    if (spotOutputAmount.equalTo(ZERO)) return ZERO_PERCENT\n\n    const preTaxOutputAmount = this.outputAmount.divide(new Fraction(ONE).subtract(this.outputTax))\n    const priceImpact = spotOutputAmount.subtract(preTaxOutputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[]\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedMixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev4, amount } of v4Routes) {\n      const v4Trade = await V4TradeSDK.fromRoute(routev4, amount, tradeType)\n      const { inputAmount, outputAmount } = v4Trade\n\n      populatedV4Routes.push({\n        routev4,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    if (mixedRoutes) {\n      for (const { mixedRoute, amount } of mixedRoutes) {\n        const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(mixedRoute, amount, tradeType)\n        const { inputAmount, outputAmount } = mixedRouteTrade\n\n        populatedMixedRoutes.push({\n          mixedRoute,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      v4Routes: populatedV4Routes,\n      mixedRoutes: populatedMixedRoutes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput> | MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let mixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n    } else if (route instanceof V3RouteSDK) {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n    } else if (route instanceof V4RouteSDK) {\n      const v4Trade = await V4TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v4Trade\n      v4Routes = [{ routev4: route, inputAmount, outputAmount }]\n    } else if (route instanceof MixedRouteSDK) {\n      const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = mixedRouteTrade\n      mixedRoutes = [{ mixedRoute: route, inputAmount, outputAmount }]\n    } else {\n      throw new Error('Invalid route type')\n    }\n\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      v4Routes,\n      mixedRoutes,\n      tradeType,\n    })\n  }\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency } from '@uniswap/sdk-core'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\nimport { V2_FEE_PATH_PLACEHOLDER } from '../constants'\n\ntype TPool = Pair | V3Pool | V4Pool\n/**\n * Converts a route to a hex encoded path\n * @notice only supports exactIn route encodings\n * @param route the mixed path to convert to an encoded path\n * @returns the exactIn encoded path\n */\nexport function encodeMixedRouteToPath(route: MixedRouteSDK<Currency, Currency>): string {\n  const firstInputToken: Currency = route.input.wrapped\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Currency; path: (string | number)[]; types: string[] },\n      pool: TPool,\n      index\n    ): { inputToken: Currency; path: (string | number)[]; types: string[] } => {\n      if (pool instanceof V4Pool) throw 'Encoding mixed routes with V4 not supported'\n      const outputToken: Currency = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [\n            inputToken.wrapped.address,\n            pool instanceof V3Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER,\n            outputToken.wrapped.address,\n          ],\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool instanceof V3Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.wrapped.address],\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return pack(types, path)\n}\n","import { Currency, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\n * @param route\n * @returns a nested array of Pools or Pairs in the order of the route\n */\nexport const partitionMixedRouteByProtocol = (route: MixedRouteSDK<Currency, Currency>): TPool[][] => {\n  let acc = []\n\n  let left = 0\n  let right = 0\n  while (right < route.pools.length) {\n    if (\n      (route.pools[left] instanceof V3Pool && route.pools[right] instanceof Pair) ||\n      (route.pools[left] instanceof Pair && route.pools[right] instanceof V3Pool)\n    ) {\n      acc.push(route.pools.slice(left, right))\n      left = right\n    }\n    // seek forward with right pointer\n    right++\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right))\n    }\n  }\n  return acc\n}\n\n/**\n * Simple utility function to get the output of an array of Pools or Pairs\n * @param pools\n * @param firstInputToken\n * @returns the output token of the last pool in the array\n */\nexport const getOutputOfPools = (pools: TPool[], firstInputToken: Currency): Currency => {\n  const { inputToken: outputToken } = pools.reduce(\n    ({ inputToken }, pool: TPool): { inputToken: Currency } => {\n      if (!pool.involvesToken(inputToken as Token)) throw new Error('PATH')\n      const outputToken: Currency = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      return {\n        inputToken: outputToken,\n      }\n    },\n    { inputToken: firstInputToken }\n  )\n  return outputToken\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Pool as V3Pool,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { MixedRoute, RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\nimport { MixedRouteTrade } from './entities/mixedRoute/trade'\nimport { encodeMixedRouteToPath } from './utils/encodeMixedRouteToPath'\nimport { MixedRouteSDK } from './entities/mixedRoute/route'\nimport { partitionMixedRouteByProtocol, getOutputOfPools } from './utils'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | MixedRouteTrade<Currency, Currency, TradeType>\n  | (\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    )[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * @notice Generates the calldata for a Swap with a V2 Route.\n   * @param trade The V2Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  /**\n   * @notice Generates the calldata for a Swap with a V3 Route.\n   * @param trade The V3Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  /**\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\n   * @param trade The MixedRouteTrade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeMixedRouteSwap(\n    trade: MixedRouteTrade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    invariant(trade.tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      if (route.pools.some((pool) => pool instanceof V4Pool)) throw 'Encoding mixed routes with V4 not supported'\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n        return route.pools.every((pool) => pool instanceof V3Pool)\n      }\n\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          const exactInputSingleParams = {\n            tokenIn: route.path[0].wrapped.address,\n            tokenOut: route.path[1].wrapped.address,\n            fee: (route.pools as V3Pool[])[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const path = route.path.map((token) => token.wrapped.address)\n\n          const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n        }\n      } else {\n        const sections = partitionMixedRouteByProtocol(route)\n\n        const isLastSectionInRoute = (i: number) => {\n          return i === sections.length - 1\n        }\n\n        let outputToken\n        let inputToken = route.input.wrapped\n\n        for (let i = 0; i < sections.length; i++) {\n          const section = sections[i]\n          /// Now, we get output of this section\n          outputToken = getOutputOfPools(section, inputToken)\n\n          const newRouteOriginal = new MixedRouteSDK(\n            [...section],\n            section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n            outputToken\n          )\n          const newRoute = new MixedRoute(newRouteOriginal)\n\n          /// Previous output is now input\n          inputToken = outputToken.wrapped\n\n          if (mixedRouteIsAllV3(newRoute)) {\n            const path: string = encodeMixedRouteToPath(newRoute)\n            const exactInputParams = {\n              path,\n              // By default router holds funds until the last swap, then it is sent to the recipient\n              // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n              // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n              recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n              amountIn: i === 0 ? amountIn : 0,\n              amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut,\n            }\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n          } else {\n            const exactInputParams = [\n              i === 0 ? amountIn : 0, // amountIn\n              !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n              newRoute.path.map((token) => token.wrapped.address),\n              isLastSectionInRoute(i) ? recipient : ADDRESS_THIS, // to\n            ]\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n          }\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade:\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every(\n          (swap) =>\n            swap.route.protocol === Protocol.V3 ||\n            swap.route.protocol === Protocol.V2 ||\n            swap.route.protocol === Protocol.MIXED\n        ),\n        'UNSUPPORTED_PROTOCOL (encoding routes with v4 not supported)'\n      )\n\n      let individualTrades: (\n        | V2Trade<Currency, Currency, TradeType>\n        | V3Trade<Currency, Currency, TradeType>\n        | MixedRouteTrade<Currency, Currency, TradeType>\n      )[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol === Protocol.V2) {\n          individualTrades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType === TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol === Protocol.V3) {\n          individualTrades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else if (route.protocol === Protocol.MIXED) {\n          individualTrades.push(\n            /// we can change the naming of this function on MixedRouteTrade if needed\n            MixedRouteTrade.createUncheckedTrade({\n              route: route as MixedRoute<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n        }\n      }\n      trades = individualTrades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) =>\n        numberOfTrades + (trade instanceof V3Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else if (trade instanceof V3Trade) {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (const calldata of SwapRouter.encodeMixedRouteSwap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else {\n        throw new Error('Unsupported trade object')\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n      | (\n          | V2Trade<Currency, Currency, TradeType>\n          | V3Trade<Currency, Currency, TradeType>\n          | MixedRouteTrade<Currency, Currency, TradeType>\n        )[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): {\n    positionAmountIn: CurrencyAmount<Currency>\n    positionAmountOut: CurrencyAmount<Currency>\n  } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["ADDRESS_ZERO","MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","V2_FEE_PATH_PLACEHOLDER","ZERO_PERCENT","Percent","ONE_HUNDRED_PERCENT","ApprovalTypes","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","process","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","_position$mintAmounts","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Error","Interface","abi","validateAndParseBytes32","bytes32","match","toLowerCase","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","MixedRouteSDK","pools","input","output","chainId","allOnSameChain","every","V4Pool","adjustedInput","involvesToken","lastPool","tokenPath","_iterator","_createForOfIteratorHelperLoose","entries","_step","done","_step$value","value","i","currentInputToken","equals","nextToken","push","path","_createClass","key","get","_midPrice","price","slice","reduce","_ref","nextInput","token0Price","asFraction","token1Price","Price","denominator","numerator","getOutputAmount","_x","_x2","_getOutputAmount","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","amountIn","wrap","_callee$","_context","prev","next","involvesCurrency","currency","abrupt","sent","stop","tradeComparator","a","b","inputAmount","outputAmount","equalTo","aHops","swaps","total","cur","route","bHops","MixedRouteTrade","routes","tradeType","inputCurrency","outputCurrency","_ref2","_ref3","numPools","map","_ref4","poolIdentifierSet","Set","_iterator2","_step2","add","poolId","V3Pool","getAddress","Pair","pair","size","TradeType","EXACT_INPUT","fromRoute","_fromRoute","amounts","_yield$getOutputAmoun","_outputAmount","CurrencyAmount","fromFractionalAmount","_x3","fromRoutes","_fromRoutes","_callee2","populatedRoutes","_iterator3","_step3","_step3$value","_yield$getOutputAmoun2","_outputAmount2","_callee2$","_context2","_x4","_x5","createUncheckedTrade","constructorArguments","_extends","createUncheckedTradeWithMultipleRoutes","_proto","prototype","minimumAmountOut","amountOut","slippageAdjustedAmountOut","Fraction","invert","fromRawAmount","maximumAmountIn","worstExecutionPrice","bestTradeExactIn","_bestTradeExactIn","_callee3","currencyAmountIn","currencyOut","_temp","currentPools","nextAmountIn","bestTrades","_ref5$maxNumResults","_ref5","maxNumResults","_ref5$maxHops","maxHops","_context3","amountInAdjusted","reserve0","reserve1","t0","_ref6","t1","isInsufficientInputAmountError","t2","sortedInsert","t3","concat","t4","t5","t6","poolsExcludingThisPool","_x6","_x7","_x8","_x9","_x10","_x11","_x12","_inputAmount","totalInputFromRoutes","_ref7","totalOutputFromRoutes","_ref8","_this$_executionPrice","_executionPrice","_priceImpact","spotOutputAmount","_iterator4","_step4","_step4$value","midPrice","quote","priceImpact","subtract","divide","Protocol","RouteV2","_V2RouteSDK","_inheritsLoose","v2Route","_this","call","pairs","V2","V2RouteSDK","RouteV3","_V3RouteSDK","v3Route","_this2","V3","V3RouteSDK","RouteV4","_V4RouteSDK","v4Route","_this3","V4","currencyPath","V4RouteSDK","MixedRoute","_MixedRouteSDK","mixedRoute","_this4","MIXED","Trade","v2Routes","v3Routes","v4Routes","mixedRoutes","routev2","_step2$value","routev3","routev4","_iterator5","_step5","_iterator6","_step6","EXACT_OUTPUT","slippageAdjustedAmountIn","populatedV2Routes","populatedV3Routes","populatedV4Routes","populatedMixedRoutes","_iterator7","_step7","_step7$value","_amount","v2Trade","_inputAmount4","_outputAmount4","_iterator8","_step8","_step8$value","_amount2","v3Trade","_inputAmount5","_outputAmount5","_iterator9","_step9","_step9$value","_amount3","v4Trade","_inputAmount6","_outputAmount6","_iterator10","_step10","_step10$value","mixedRouteTrade","V2TradeSDK","V3TradeSDK","V4TradeSDK","MixedRouteTradeSDK","_inputAmount7","_outputAmount7","_inputAmount8","_outputAmount8","_inputAmount9","_outputAmount9","isNative","sellFeeBps","toNumber","buyFeeBps","outputTax","_iterator11","_step11","_step11$value","postTaxInputAmount","inputTax","preTaxOutputAmount","encodeMixedRouteToPath","firstInputToken","_route$pools$reduce","index","inputToken","types","outputToken","pack","partitionMixedRouteByProtocol","acc","left","right","getOutputOfPools","_pools$reduce","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","exactInputParams","exactOutputParams","encodeV3Swap","singleHop","exactInputSingleParams","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","exactOutputSingleParams","amountInMaximum","encodeRouteToPath","encodeMixedRouteSwap","_loop","mixedRouteIsAllV3","sections","isLastSectionInRoute","section","newRouteOriginal","newRoute","encodeSwaps","trades","isSwapAndAdd","swap","protocol","individualTrades","V2Trade","V3Trade","numberOfTrades","sampleTrade","inputIsNative","outputIsNative","inputTokenPermit","isToken","SelfPermit","encodePermit","calldata","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","_SwapRouter$encodeSwa","riskOfPartialFill","encodeRefundETH","deadlineOrPreviousBlockhash","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","_SwapRouter$encodeSwa2","totalAmountSwapped","outputTokenPermit","zeroForOne","_SwapRouter$getPositi","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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"}