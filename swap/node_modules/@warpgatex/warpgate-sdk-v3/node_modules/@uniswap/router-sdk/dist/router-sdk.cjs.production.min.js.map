{"version":3,"file":"router-sdk.cjs.production.min.js","sources":["../src/approveAndCall.ts","../src/constants.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/mixedRoute/route.ts","../src/utils/getOutputAmount.ts","../src/entities/mixedRoute/trade.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/utils/encodeMixedRouteToPath.ts","../src/utils/index.ts","../src/swapRouter.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length === 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw new Error('Error: invalid ApprovalType')\n    }\n  }\n}\n","import { Percent } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\n\nexport const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// = 1 << 23 or 100000000000000000000000\nexport const V2_FEE_PATH_PLACEHOLDER = 8388608\n\nexport const ZERO_PERCENT = new Percent(ZERO)\nexport const ONE_HUNDRED_PERCENT = new Percent(100, 100)\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Represents a list of pools or pairs through which a swap can occur\n * @template TInput The input token\n * @template TOutput The output token\n */\nexport class MixedRouteSDK<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: TPool[]\n  public readonly path: Currency[]\n  public readonly input: TInput\n  public readonly output: TOutput\n  public readonly adjustedInput: Currency // routes with v2/v3 initial pool must wrap native input currency before trading\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  /**\n   * Creates an instance of route.\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\n   * @param input The input token\n   * @param output The output token\n   */\n  public constructor(pools: TPool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every((pool) => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    if (pools[0] instanceof V4Pool) {\n      this.adjustedInput = pools[0].involvesToken(input) ? input : input.wrapped\n    } else {\n      this.adjustedInput = input.wrapped // no native currencies in v2/v3\n    }\n\n    invariant(pools[0].involvesToken(this.adjustedInput as Token), 'INPUT')\n    const lastPool = pools[pools.length - 1]\n    if (lastPool instanceof V4Pool) {\n      invariant(lastPool.involvesToken(output) || lastPool.involvesToken(output.wrapped), 'OUTPUT')\n    } else {\n      invariant(lastPool.involvesToken(output.wrapped as Token), 'OUTPUT')\n    }\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Currency[] = [this.adjustedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.path = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price.asFraction),\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price.asFraction),\n            }\n      },\n\n      this.pools[0].token0.equals(this.adjustedInput)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price.asFraction,\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price.asFraction,\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import { Currency, CurrencyAmount } from '@uniswap/sdk-core'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\n\ntype TPool = Pair | V3Pool | V4Pool\n\nexport async function getOutputAmount(\n  pool: TPool,\n  amountIn: CurrencyAmount<Currency>\n): Promise<[CurrencyAmount<Currency>, TPool]> {\n  if (pool instanceof V4Pool) {\n    if (pool.involvesCurrency(amountIn.currency)) {\n      return await pool.getOutputAmount(amountIn)\n    } else if (pool.involvesCurrency(amountIn.currency.wrapped)) {\n      return await pool.getOutputAmount(amountIn.wrapped)\n    }\n  }\n  return await pool.getOutputAmount(amountIn.wrapped)\n}\n","import { Currency, Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { BestTradeOptions, Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../../constants'\nimport { MixedRouteSDK } from './route'\nimport { getOutputAmount } from '../../utils/getOutputAmount'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n * @param a The first trade to compare\n * @param b The second trade to compare\n * @returns A sorted ordering for two neighboring elements in a trade array\n */\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: MixedRouteTrade<TInput, TOutput, TTradeType>,\n  b: MixedRouteTrade<TInput, TOutput, TTradeType>\n) {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      const aHops = a.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      const bHops = b.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      return aHops - bHops\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n/**\n * Represents a trade executed against a set of routes where some percentage of the input is\n * split across each route.\n *\n * Each route has its own set of pools. Pools can not be re-used across routes.\n *\n * Does not account for slippage, i.e., changes in price environment that can occur between\n * the time the trade is submitted and when it is executed.\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n */\nexport class MixedRouteTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\n   * this will return an error.\n   *\n   * When the trade consists of just a single route, this returns the route of the trade,\n   * i.e. which pools the trade goes through.\n   */\n  public get route(): MixedRouteSDK<TInput, TOutput> {\n    invariant(this.swaps.length === 1, 'MULTIPLE_ROUTES')\n    return this.swaps[0].route\n  }\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade.\n   */\n  public readonly swaps: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The cached result of the input amount computation\n   * @private\n   */\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  /**\n   * The cached result of the output amount computation\n   * @private\n   */\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  /**\n   * The cached result of the computed execution price\n   * @private\n   */\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Constructs a trade by simulating swaps through the given route\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param route route to swap through\n   * @param amount the amount specified, either input or output, depending on tradeType\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The route\n   */\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const amounts: CurrencyAmount<Currency>[] = new Array(route.path.length)\n    let inputAmount: CurrencyAmount<TInput>\n    let outputAmount: CurrencyAmount<TOutput>\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n    invariant(amount.currency.equals(route.input), 'INPUT')\n\n    amounts[0] = route.pools[0] instanceof V4Pool ? amount : amount.wrapped\n    for (let i = 0; i < route.path.length - 1; i++) {\n      const pool = route.pools[i]\n      const [outputAmount] = await getOutputAmount(pool, amounts[i])\n      amounts[i + 1] = outputAmount\n    }\n\n    inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n    outputAmount = CurrencyAmount.fromFractionalAmount(\n      route.output,\n      amounts[amounts.length - 1].numerator,\n      amounts[amounts.length - 1].denominator\n    )\n\n    return new MixedRouteTrade({\n      routes: [{ inputAmount, outputAmount, route }],\n      tradeType,\n    })\n  }\n\n  /**\n   * Constructs a trade from routes by simulating swaps\n   *\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param routes the routes to swap through and how much of the amount should be routed through each\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The trade\n   */\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    routes: {\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n      route: MixedRouteSDK<TInput, TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const populatedRoutes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, amount } of routes) {\n      const amounts: CurrencyAmount<Currency>[] = new Array(route.path.length)\n      let inputAmount: CurrencyAmount<TInput>\n      let outputAmount: CurrencyAmount<TOutput>\n\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      amounts[0] = CurrencyAmount.fromFractionalAmount(route.adjustedInput, amount.numerator, amount.denominator)\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pool = route.pools[i]\n        const [outputAmount] = await getOutputAmount(pool, amounts[i])\n        amounts[i + 1] = outputAmount\n      }\n\n      outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        amounts[amounts.length - 1].numerator,\n        amounts[amounts.length - 1].denominator\n      )\n\n      populatedRoutes.push({ route, inputAmount, outputAmount })\n    }\n\n    return new MixedRouteTrade({\n      routes: populatedRoutes,\n      tradeType,\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTrade<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade({\n      ...constructorArguments,\n      routes: [\n        {\n          inputAmount: constructorArguments.inputAmount,\n          outputAmount: constructorArguments.outputAmount,\n          route: constructorArguments.route,\n        },\n      ],\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTradeWithMultipleRoutes<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade(constructorArguments)\n  }\n\n  /**\n   * Construct a trade by passing in the pre-computed property values\n   * @param routes The routes through which the trade occurs\n   * @param tradeType The type of trade, exact input or exact output\n   */\n  private constructor({\n    routes,\n    tradeType,\n  }: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    const inputCurrency = routes[0].inputAmount.currency\n    const outputCurrency = routes[0].outputAmount.currency\n    invariant(\n      routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolIdentifierSet = new Set<string>()\n    for (const { route } of routes) {\n      for (const pool of route.pools) {\n        if (pool instanceof V4Pool) {\n          poolIdentifierSet.add(pool.poolId)\n        } else if (pool instanceof V3Pool) {\n          poolIdentifierSet.add(V3Pool.getAddress(pool.token0, pool.token1, pool.fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolIdentifierSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n\n    invariant(numPools === poolIdentifierSet.size, 'POOLS_DUPLICATED')\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    this.swaps = routes\n    this.tradeType = tradeType\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    /// does not support exactOutput, as enforced in the constructor\n    const slippageAdjustedAmountOut = new Fraction(ONE)\n      .add(slippageTolerance)\n      .invert()\n      .multiply(amountOut.quotient).quotient\n    return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    return amountIn\n    /// does not support exactOutput\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pools the pools to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\n   * @param currentPools used in recursion; the current list of pools\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   * @returns The exact in trade\n   */\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pools: TPool[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPools: TPool[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Promise<MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\n    invariant(pools.length > 0, 'POOLS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn\n    for (let i = 0; i < pools.length; i++) {\n      const pool = pools[i]\n      const amountInAdjusted = pool instanceof V4Pool ? amountIn : amountIn.wrapped\n      // pool irrelevant\n      if (!pool.token0.equals(amountInAdjusted.currency) && !pool.token1.equals(amountInAdjusted.currency)) continue\n      if (pool instanceof Pair) {\n        if ((pool as Pair).reserve0.equalTo(ZERO) || (pool as Pair).reserve1.equalTo(ZERO)) continue\n      }\n\n      let amountOut: CurrencyAmount<Currency>\n      try {\n        ;[amountOut] =\n          pool instanceof V4Pool\n            ? await pool.getOutputAmount(amountInAdjusted)\n            : await pool.getOutputAmount(amountInAdjusted.wrapped)\n      } catch (error) {\n        // input too low\n        // @ts-ignore[2571] error is unknown\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.wrapped.equals(currencyOut.wrapped)) {\n        sortedInsert(\n          bestTrades,\n          await MixedRouteTrade.fromRoute(\n            new MixedRouteSDK([...currentPools, pool], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pools.length > 1) {\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await MixedRouteTrade.bestTradeExactIn(\n          poolsExcludingThisPool,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPools, pool],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n  V4 = 'V4',\n  MIXED = 'MIXED',\n}\n","// entities/route.ts\n\nimport { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Route as V4RouteSDK, Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { MixedRouteSDK } from './mixedRoute/route'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pair | V3Pool | V4Pool> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Currency[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, V3Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n\n// V4 route wrapper\nexport class RouteV4<TInput extends Currency, TOutput extends Currency>\n  extends V4RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, V4Pool>\n{\n  public readonly protocol: Protocol = Protocol.V4\n  public readonly path: Currency[]\n\n  constructor(v4Route: V4RouteSDK<TInput, TOutput>) {\n    super(v4Route.pools, v4Route.input, v4Route.output)\n    this.path = v4Route.currencyPath\n  }\n}\n\n// Mixed route wrapper\nexport class MixedRoute<TInput extends Currency, TOutput extends Currency>\n  extends MixedRouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>\n{\n  public readonly protocol: Protocol = Protocol.MIXED\n\n  constructor(mixedRoute: MixedRouteSDK<TInput, TOutput>) {\n    super(mixedRoute.pools, mixedRoute.input, mixedRoute.output)\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool, Route as V4RouteSDK, Trade as V4TradeSDK } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ONE_HUNDRED_PERCENT, ZERO, ZERO_PERCENT } from '../constants'\nimport { MixedRouteSDK } from './mixedRoute/route'\nimport { MixedRouteTrade as MixedRouteTradeSDK } from './mixedRoute/trade'\nimport { IRoute, MixedRoute, RouteV2, RouteV3, RouteV4 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | V3Pool | V4Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    v4Routes,\n    tradeType,\n    mixedRoutes,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v4 routes\n    for (const { routev4, inputAmount, outputAmount } of v4Routes) {\n      const route = new RouteV4(routev4)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap mixedRoutes\n    if (mixedRoutes) {\n      for (const { mixedRoute, inputAmount, outputAmount } of mixedRoutes) {\n        const route = new MixedRoute(mixedRoute)\n        this.routes.push(route)\n        this.swaps.push({\n          route,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    if (this.swaps.length === 0) {\n      throw new Error('No routes provided when calling Trade constructor')\n    }\n\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolIdentifierSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (pool instanceof V4Pool) {\n          poolIdentifierSet.add(pool.poolId)\n        } else if (pool instanceof V3Pool) {\n          poolIdentifierSet.add(V3Pool.getAddress(pool.token0, pool.token1, pool.fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolIdentifierSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n    invariant(numPools === poolIdentifierSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * Returns the sell tax of the input token\n   */\n  public get inputTax(): Percent {\n    const inputCurrency = this.inputAmount.currency\n    if (inputCurrency.isNative || !inputCurrency.wrapped.sellFeeBps) return ZERO_PERCENT\n\n    return new Percent(inputCurrency.wrapped.sellFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * Returns the buy tax of the output token\n   */\n  public get outputTax(): Percent {\n    const outputCurrency = this.outputAmount.currency\n    if (outputCurrency.isNative || !outputCurrency.wrapped.buyFeeBps) return ZERO_PERCENT\n\n    return new Percent(outputCurrency.wrapped.buyFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the expected execution price\n   * In order to exclude token taxes from the price impact calculation, the spot price is calculated\n   * using a ratio of values that go into the pools, which are the post-tax input amount and pre-tax output amount.\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    // returns 0% price impact even though this may be inaccurate as a swap may have occured.\n    // because we're unable to derive the pre-buy-tax amount, use 0% as a placeholder.\n    if (this.outputTax.equalTo(ONE_HUNDRED_PERCENT)) return ZERO_PERCENT\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      const postTaxInputAmount = inputAmount.multiply(new Fraction(ONE).subtract(this.inputTax))\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(postTaxInputAmount))\n    }\n\n    // if the total output of this trade is 0, then most likely the post-tax input was also 0, and therefore this swap\n    // does not move the pools' market price\n    if (spotOutputAmount.equalTo(ZERO)) return ZERO_PERCENT\n\n    const preTaxOutputAmount = this.outputAmount.divide(new Fraction(ONE).subtract(this.outputTax))\n    const priceImpact = spotOutputAmount.subtract(preTaxOutputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[]\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedMixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev4, amount } of v4Routes) {\n      const v4Trade = await V4TradeSDK.fromRoute(routev4, amount, tradeType)\n      const { inputAmount, outputAmount } = v4Trade\n\n      populatedV4Routes.push({\n        routev4,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    if (mixedRoutes) {\n      for (const { mixedRoute, amount } of mixedRoutes) {\n        const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(mixedRoute, amount, tradeType)\n        const { inputAmount, outputAmount } = mixedRouteTrade\n\n        populatedMixedRoutes.push({\n          mixedRoute,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      v4Routes: populatedV4Routes,\n      mixedRoutes: populatedMixedRoutes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput> | MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v4Routes: {\n      routev4: V4RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let mixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n    } else if (route instanceof V3RouteSDK) {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n    } else if (route instanceof V4RouteSDK) {\n      const v4Trade = await V4TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v4Trade\n      v4Routes = [{ routev4: route, inputAmount, outputAmount }]\n    } else if (route instanceof MixedRouteSDK) {\n      const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = mixedRouteTrade\n      mixedRoutes = [{ mixedRoute: route, inputAmount, outputAmount }]\n    } else {\n      throw new Error('Invalid route type')\n    }\n\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      v4Routes,\n      mixedRoutes,\n      tradeType,\n    })\n  }\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency } from '@uniswap/sdk-core'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\nimport { V2_FEE_PATH_PLACEHOLDER } from '../constants'\n\ntype TPool = Pair | V3Pool | V4Pool\n/**\n * Converts a route to a hex encoded path\n * @notice only supports exactIn route encodings\n * @param route the mixed path to convert to an encoded path\n * @returns the exactIn encoded path\n */\nexport function encodeMixedRouteToPath(route: MixedRouteSDK<Currency, Currency>): string {\n  const firstInputToken: Currency = route.input.wrapped\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Currency; path: (string | number)[]; types: string[] },\n      pool: TPool,\n      index\n    ): { inputToken: Currency; path: (string | number)[]; types: string[] } => {\n      if (pool instanceof V4Pool) throw 'Encoding mixed routes with V4 not supported'\n      const outputToken: Currency = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [\n            inputToken.wrapped.address,\n            pool instanceof V3Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER,\n            outputToken.wrapped.address,\n          ],\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool instanceof V3Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.wrapped.address],\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return pack(types, path)\n}\n","import { Currency, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool as V3Pool } from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\n\ntype TPool = Pair | V3Pool | V4Pool\n\n/**\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\n * @param route\n * @returns a nested array of Pools or Pairs in the order of the route\n */\nexport const partitionMixedRouteByProtocol = (route: MixedRouteSDK<Currency, Currency>): TPool[][] => {\n  let acc = []\n\n  let left = 0\n  let right = 0\n  while (right < route.pools.length) {\n    if (\n      (route.pools[left] instanceof V3Pool && route.pools[right] instanceof Pair) ||\n      (route.pools[left] instanceof Pair && route.pools[right] instanceof V3Pool)\n    ) {\n      acc.push(route.pools.slice(left, right))\n      left = right\n    }\n    // seek forward with right pointer\n    right++\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right))\n    }\n  }\n  return acc\n}\n\n/**\n * Simple utility function to get the output of an array of Pools or Pairs\n * @param pools\n * @param firstInputToken\n * @returns the output token of the last pool in the array\n */\nexport const getOutputOfPools = (pools: TPool[], firstInputToken: Currency): Currency => {\n  const { inputToken: outputToken } = pools.reduce(\n    ({ inputToken }, pool: TPool): { inputToken: Currency } => {\n      if (!pool.involvesToken(inputToken as Token)) throw new Error('PATH')\n      const outputToken: Currency = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      return {\n        inputToken: outputToken,\n      }\n    },\n    { inputToken: firstInputToken }\n  )\n  return outputToken\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Pool as V3Pool,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport { Pool as V4Pool } from '@uniswap/v4-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { MixedRoute, RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\nimport { MixedRouteTrade } from './entities/mixedRoute/trade'\nimport { encodeMixedRouteToPath } from './utils/encodeMixedRouteToPath'\nimport { MixedRouteSDK } from './entities/mixedRoute/route'\nimport { partitionMixedRouteByProtocol, getOutputOfPools } from './utils'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | MixedRouteTrade<Currency, Currency, TradeType>\n  | (\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    )[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * @notice Generates the calldata for a Swap with a V2 Route.\n   * @param trade The V2Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  /**\n   * @notice Generates the calldata for a Swap with a V3 Route.\n   * @param trade The V3Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  /**\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\n   * @param trade The MixedRouteTrade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeMixedRouteSwap(\n    trade: MixedRouteTrade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    invariant(trade.tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      if (route.pools.some((pool) => pool instanceof V4Pool)) throw 'Encoding mixed routes with V4 not supported'\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n        return route.pools.every((pool) => pool instanceof V3Pool)\n      }\n\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          const exactInputSingleParams = {\n            tokenIn: route.path[0].wrapped.address,\n            tokenOut: route.path[1].wrapped.address,\n            fee: (route.pools as V3Pool[])[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const path = route.path.map((token) => token.wrapped.address)\n\n          const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n        }\n      } else {\n        const sections = partitionMixedRouteByProtocol(route)\n\n        const isLastSectionInRoute = (i: number) => {\n          return i === sections.length - 1\n        }\n\n        let outputToken\n        let inputToken = route.input.wrapped\n\n        for (let i = 0; i < sections.length; i++) {\n          const section = sections[i]\n          /// Now, we get output of this section\n          outputToken = getOutputOfPools(section, inputToken)\n\n          const newRouteOriginal = new MixedRouteSDK(\n            [...section],\n            section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n            outputToken\n          )\n          const newRoute = new MixedRoute(newRouteOriginal)\n\n          /// Previous output is now input\n          inputToken = outputToken.wrapped\n\n          if (mixedRouteIsAllV3(newRoute)) {\n            const path: string = encodeMixedRouteToPath(newRoute)\n            const exactInputParams = {\n              path,\n              // By default router holds funds until the last swap, then it is sent to the recipient\n              // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n              // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n              recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n              amountIn: i === 0 ? amountIn : 0,\n              amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut,\n            }\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n          } else {\n            const exactInputParams = [\n              i === 0 ? amountIn : 0, // amountIn\n              !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n              newRoute.path.map((token) => token.wrapped.address),\n              isLastSectionInRoute(i) ? recipient : ADDRESS_THIS, // to\n            ]\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n          }\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade:\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every(\n          (swap) =>\n            swap.route.protocol === Protocol.V3 ||\n            swap.route.protocol === Protocol.V2 ||\n            swap.route.protocol === Protocol.MIXED\n        ),\n        'UNSUPPORTED_PROTOCOL (encoding routes with v4 not supported)'\n      )\n\n      let individualTrades: (\n        | V2Trade<Currency, Currency, TradeType>\n        | V3Trade<Currency, Currency, TradeType>\n        | MixedRouteTrade<Currency, Currency, TradeType>\n      )[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol === Protocol.V2) {\n          individualTrades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType === TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol === Protocol.V3) {\n          individualTrades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else if (route.protocol === Protocol.MIXED) {\n          individualTrades.push(\n            /// we can change the naming of this function on MixedRouteTrade if needed\n            MixedRouteTrade.createUncheckedTrade({\n              route: route as MixedRoute<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n        }\n      }\n      trades = individualTrades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) =>\n        numberOfTrades + (trade instanceof V3Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else if (trade instanceof V3Trade) {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (const calldata of SwapRouter.encodeMixedRouteSwap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else {\n        throw new Error('Unsupported trade object')\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n      | (\n          | V2Trade<Currency, Currency, TradeType>\n          | V3Trade<Currency, Currency, TradeType>\n          | MixedRouteTrade<Currency, Currency, TradeType>\n        )[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): {\n    positionAmountIn: CurrencyAmount<Currency>\n    positionAmountOut: CurrencyAmount<Currency>\n  } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["ApprovalTypes","MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","ZERO_PERCENT","Percent","ONE_HUNDRED_PERCENT","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","_position$mintAmounts","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Error","Interface","abi","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","bytes32","match","toLowerCase","validateAndParseBytes32","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","MixedRouteSDK","pools","input","output","this","chainId","every","adjustedInput","V4Pool","involvesToken","lastPool","_step","tokenPath","_iterator","_createForOfIteratorHelperLoose","entries","done","_step$value","value","currentInputToken","equals","nextToken","push","path","_createClass","key","get","_midPrice","price","slice","reduce","_ref","nextInput","token0Price","asFraction","token1Price","Price","denominator","numerator","getOutputAmount","_x","_x2","_getOutputAmount","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","amountIn","wrap","_context","prev","next","involvesCurrency","currency","abrupt","sent","stop","tradeComparator","a","b","inputAmount","outputAmount","equalTo","swaps","total","cur","route","Protocol","MixedRouteTrade","routes","tradeType","inputCurrency","outputCurrency","_ref2","_ref3","numPools","map","_ref4","poolIdentifierSet","Set","_step2","_iterator2","add","poolId","V3Pool","getAddress","Pair","size","TradeType","EXACT_INPUT","fromRoute","_fromRoute","amounts","i","CurrencyAmount","fromFractionalAmount","_x3","fromRoutes","_fromRoutes","_callee2","populatedRoutes","_iterator3","_step3","_step3$value","_context2","_x4","_x5","createUncheckedTrade","constructorArguments","_extends","createUncheckedTradeWithMultipleRoutes","_proto","prototype","minimumAmountOut","amountOut","slippageAdjustedAmountOut","Fraction","invert","fromRawAmount","maximumAmountIn","worstExecutionPrice","bestTradeExactIn","_bestTradeExactIn","_callee3","currencyAmountIn","currencyOut","_temp","currentPools","nextAmountIn","bestTrades","maxNumResults","_ref5$maxNumResults","maxHops","_ref5$maxHops","_ref5","_context3","amountInAdjusted","reserve0","reserve1","t0","t1","isInsufficientInputAmountError","t2","sortedInsert","t3","concat","t4","t5","t6","poolsExcludingThisPool","_x6","_x7","_x8","_x9","_x10","_x11","_x12","_inputAmount","totalInputFromRoutes","_ref7","_outputAmount","totalOutputFromRoutes","_ref8","_this$_executionPrice","_executionPrice","_priceImpact","_step4","spotOutputAmount","_iterator4","_step4$value","midPrice","quote","priceImpact","subtract","divide","RouteV2","_V2RouteSDK","v2Route","_this","call","pairs","V2","_inheritsLoose","V2RouteSDK","RouteV3","_V3RouteSDK","v3Route","_this2","V3","V3RouteSDK","RouteV4","_V4RouteSDK","v4Route","_this3","V4","currencyPath","V4RouteSDK","MixedRoute","_MixedRouteSDK","mixedRoute","_this4","MIXED","Trade","v2Routes","v3Routes","v4Routes","mixedRoutes","routev2","_step2$value","routev3","routev4","_step5","_iterator5","_step6","_iterator6","EXACT_OUTPUT","slippageAdjustedAmountIn","populatedV2Routes","populatedV3Routes","populatedV4Routes","populatedMixedRoutes","_iterator7","_step7","_step7$value","v2Trade","_iterator8","_step8","_step8$value","_amount2","v3Trade","_iterator9","_step9","_step9$value","_amount3","v4Trade","_iterator10","_step10","_step10$value","mixedRouteTrade","V2TradeSDK","V3TradeSDK","V4TradeSDK","MixedRouteTradeSDK","_ref6","isNative","sellFeeBps","toNumber","buyFeeBps","outputTax","_step11","_iterator11","_step11$value","postTaxInputAmount","inputTax","preTaxOutputAmount","encodeMixedRouteToPath","_route$pools$reduce","index","inputToken","types","outputToken","pack","partitionMixedRouteByProtocol","acc","left","right","getOutputOfPools","firstInputToken","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","encodeV3Swap","singleHop","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","amountInMaximum","encodeRouteToPath","encodeMixedRouteSwap","_loop","mixedRouteIsAllV3","sections","isLastSectionInRoute","section","newRouteOriginal","newRoute","exactInputParams","encodeSwaps","trades","isSwapAndAdd","swap","protocol","individualTrades","V2Trade","V3Trade","numberOfTrades","sampleTrade","inputIsNative","outputIsNative","inputTokenPermit","isToken","SelfPermit","encodePermit","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","_SwapRouter$encodeSwa","riskOfPartialFill","encodeRefundETH","calldata","deadlineOrPreviousBlockhash","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","_SwapRouter$encodeSwa2","totalAmountSwapped","outputTokenPermit","zeroForOne","_SwapRouter$getPositi","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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"}