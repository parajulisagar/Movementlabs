import { BigNumber, ethers } from "ethers";
import {
  ChainId,
  ERC20_ABI,
  MULTICALL_ABI,
  MULTICALL_CONTRACT_ADDRESS,
} from "./constants";
import {
  FeeAmount,
  TICK_SPACINGS,
  nearestUsableTick,
} from "@warpgatex/warp-v3-sdk";

/**
 * Retrieves the token balance of a wallet for multiple token addresses.
 * @param tokenAddresses - An array of token addresses.
 * @param owner - An array of wallet addresses.
 * @param provider - The ethers provider used to interact with the blockchain.
 * @returns An object containing the token balances for each wallet address.
 */
export async function getWalletTokenBalance(
  tokenAddresses: string[],
  owner: string[],
  provider: ethers.providers.Provider,
  chainId: number
) {
  if (!Object.values(ChainId).includes(Number(chainId))) {
    throw new Error("Invalid Chain ID");
  }
  const contract = new ethers.Contract(
    MULTICALL_CONTRACT_ADDRESS[chainId],
    MULTICALL_ABI,
    provider
  );
  const calls = [];
  owner.forEach((walletAddress) => {
    tokenAddresses.forEach((tokenAddress) => {
      if (tokenAddress == ethers.constants.AddressZero) {
        calls.push({
          target: MULTICALL_CONTRACT_ADDRESS[chainId],
          callData: contract.interface.encodeFunctionData("getEthBalance", [
            walletAddress,
          ]),
          allowFailure: true,
        });
      } else {
        const tokenContract = new ethers.Contract(
          tokenAddress,
          ERC20_ABI,
          provider
        );
        calls.push({
          target: tokenAddress,
          callData: tokenContract.interface.encodeFunctionData("balanceOf", [
            walletAddress,
          ]),
          allowFailure: true,
        });
      }
    });
  });

  const result = await contract.callStatic.aggregate3(calls);
  const parsedResult = result.map((res: any) => {
    const iface = new ethers.utils.Interface(ERC20_ABI);
    const decoded = iface.decodeFunctionResult("balanceOf", res.returnData);
    return decoded[0];
  });
  const numOwners = owner.length;
  let returnObj: { [key: string]: BigNumber[] } = {};
  for (let i = 0; i < numOwners; i++) {
    const offset = parsedResult.length / numOwners;
    returnObj[owner[i]] = parsedResult.slice(i * offset, (i + 1) * offset);
  }

  return returnObj;
}

/**
 * Calculates the adjusted price based on the given price and fee amount.
 * @param price - The original price.
 * @param fee - The fee amount.
 * @returns The adjusted price.
 */
export const getAdjustedPrice = (price: number, fee: FeeAmount) => {
  const priceTick = Math.floor(Math.log(price) / Math.log(1.0001));
  const tick = nearestUsableTick(priceTick, TICK_SPACINGS[fee]);
  const adjustedPrice = Math.pow(1.0001, tick);
  return Number(adjustedPrice.toFixed(6));
};

/**
 * Calculates the next price based on the current price, fee amount, and increment.
 *
 * @param price - The current price.
 * @param fee - The fee amount.
 * @param incr - The increment value.
 * @returns The next price.
 */
export const getNextPrice = (price: number, fee: FeeAmount, incr: number) => {
  const priceTick = Math.floor(Math.log(price) / Math.log(1.0001));
  const tick = nearestUsableTick(priceTick, TICK_SPACINGS[fee]);
  const adjustedPrice = Math.pow(1.0001, tick + incr * (fee / 50));
  return Number(adjustedPrice.toFixed(6));
};
