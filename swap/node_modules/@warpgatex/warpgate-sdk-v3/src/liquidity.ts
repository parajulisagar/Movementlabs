import IUniswapV3PoolABI from "@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json";
import { BigNumber, ethers } from "ethers";
import BN from "bignumber.js";
import {
  ERC20_ABI,
  NONFUNGIBLE_POSITION_MANAGER_ABI,
  NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  SMART_ROUTER_ADDRESS,
  WETH,
  DEPLOYER_ADDRESS,
  MAX_FEE_PER_GAS,
  MAX_PRIORITY_FEE_PER_GAS,
  WETH_ABI,
  POOL_INIT_CODE_HASH,
  MULTICALL_CONTRACT_ADDRESS,
  MULTICALL_ABI,
  RPC_URL,
  ChainId,
} from "./constants";
import {
  Position,
  NonfungiblePositionManager,
  MintOptions,
  MethodParameters,
  FeeAmount,
  TICK_SPACINGS,
  nearestUsableTick,
  TickMath,
  Pool,
  CollectOptions,
  RemoveLiquidityOptions,
  computePoolAddress,
  AddLiquidityOptions,
} from "@warpgatex/warp-v3-sdk";
import { PositionMath } from "@pancakeswap/v3-sdk";
import {
  Percent,
  CurrencyAmount,
  Token,
  TradeType,
  Currency,
} from "@uniswap/sdk-core";
import { formatAmount, fromReadableAmount } from "./conversion";
import { getPoolData, getPoolInfo } from "./pool";
import {
  AlphaRouter,
  SwapType,
  parseAmount,
} from "@warpgatex/warp-smart-order-router";
import { Ether } from "./ether";
import { Protocol } from "@uniswap/router-sdk";
import { getTokenInfo } from "./token";

export enum TransactionState {
  Failed = "Failed",
  New = "New",
  Rejected = "Rejected",
  Sending = "Sending",
  Sent = "Sent",
}

export interface PositionInfo {
  positionId: number;
  tickLower: number;
  tickUpper: number;
  liquidity: BigNumber;
  tokensOwed0: BN;
  tokensOwed1: BN;
  token0: string;
  token1: string;
  fee: number;
  tokenAmount0: BN;
  tokenAmount1: BN;
  currentPrice: number;
  lowerRangePrice: number;
  upperRangePrice: number;
}

interface SwapOptions {
  slippage?: number; // 0 - 100
  deadline?: number; // timestamp
}

/**
 * Represents a liquidity client that interacts with the liquidity-related functionality of the SDK.
 */
export class liquidityClient {
  signer: ethers.Signer;
  chainId: number;
  constructor(signer: ethers.Signer, chainId: number) {
    if (!Object.values(ChainId).includes(Number(chainId))) {
      throw new Error("Invalid Chain ID");
    }
    this.signer = signer;
    this.chainId = chainId;
  }

  /**
   * Re-initializes the signer and chain ID.
   * @param signer - The signer to use for the client.
   * @param chainId - The chain ID.
   */
  public reinitialize(signer: ethers.Signer, chainId: number) {
    this.signer = signer;
    this.chainId = chainId;
  }

  /**
   * Retrieves the position IDs associated with the given address.
   *
   * @param address - The address for which to retrieve the position IDs.
   * @param chainId - The chain ID.
   * @returns An array of position IDs.
   */
  public async getPositionIds(address: string) {
    const positionContract = new ethers.Contract(
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      NONFUNGIBLE_POSITION_MANAGER_ABI,
      this.signer.provider
    );

    // Get number of positions
    const balance: number = await positionContract.balanceOf(address);

    const multicallContract = new ethers.Contract(
      MULTICALL_CONTRACT_ADDRESS[this.chainId],
      MULTICALL_ABI,
      this.signer.provider
    );

    const calls = [];
    for (let i = 0; i < balance; i++) {
      const calldata = positionContract.interface.encodeFunctionData(
        "tokenOfOwnerByIndex",
        [address, i]
      );

      calls.push({
        target: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
        callData: calldata,
        allowFailure: false,
      });
    }

    const tokenIds = await multicallContract.callStatic.aggregate3(calls);

    return tokenIds.map((tokenId: any) => {
      return BigNumber.from(tokenId.returnData);
    });
  }

  /**
   * Retrieves information about a specific position.
   * @param tokenId - The ID of the position.
   * @returns A Promise that resolves to a PositionInfo object containing the position details.
   */
  public async getPositionInfo(tokenId: number): Promise<PositionInfo> {
    const positionContract = new ethers.Contract(
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      NONFUNGIBLE_POSITION_MANAGER_ABI,
      this.signer.provider
    );

    const position = await positionContract.positions(tokenId);
    const token0Info = await getTokenInfo(position.token0, this.chainId);
    const token1Info = await getTokenInfo(position.token1, this.chainId);
    const token0 = new Token(
      this.chainId,
      position.token0,
      token0Info.decimals,
      "Token 0",
      "tIMX"
    );
    const token1 = new Token(
      this.chainId,
      position.token1,
      token1Info.decimals,
      "Token 1",
      "USDC"
    );

    const currentPoolAddress = computePoolAddress({
      factoryAddress: DEPLOYER_ADDRESS[this.chainId],
      tokenA: token0,
      tokenB: token1,
      fee: position.fee,
      initCodeHashManualOverride: POOL_INIT_CODE_HASH[this.chainId],
    });

    const poolContract = new ethers.Contract(
      currentPoolAddress,
      IUniswapV3PoolABI.abi,
      this.signer.provider
    );

    const [slot0] = await Promise.all([poolContract.slot0()]);

    const tick = slot0[1];
    const sqrtRatioX96 = slot0[0];
    const isSorted = token0.sortsBefore(token1);
    const currentPrice = isSorted
      ? 1.0001 ** tick * 10 ** (token0Info.decimals - token1Info.decimals)
      : 1.0001 ** -tick * 10 ** (token0Info.decimals - token1Info.decimals);

    const amount0 = PositionMath.getToken0Amount(
      tick,
      position.tickLower,
      position.tickUpper,
      BigInt(sqrtRatioX96.toString()),
      BigInt(position.liquidity.toString())
    );

    const amount1 = PositionMath.getToken1Amount(
      tick,
      position.tickLower,
      position.tickUpper,
      BigInt(sqrtRatioX96.toString()),
      BigInt(position.liquidity.toString())
    );

    // const lowerRangePrice = 1.0001 ** position.tickLower;
    // const upperRangePrice = 1.0001 ** position.tickUpper;
    const lowerRangePrice = isSorted
      ? 1.0001 ** position.tickLower *
        10 ** (token0Info.decimals - token1Info.decimals)
      : 1.0001 ** -position.tickLower *
        10 ** (token0Info.decimals - token1Info.decimals);
    const upperRangePrice = isSorted
      ? 1.0001 ** position.tickUpper *
        10 ** (token0Info.decimals - token1Info.decimals)
      : 1.0001 ** -position.tickUpper *
        10 ** (token0Info.decimals - token1Info.decimals);
    const MAX_UINT128 = new BN(2).pow(128).minus(1);
    const recipient = await this.signer.getAddress();
    // TODO: Fix callStatic on collect for movement contracts
    const tokenCollectFees = await positionContract.callStatic
      .collect({
        tokenId,
        recipient,
        amount0Max: MAX_UINT128.toFixed(),
        amount1Max: MAX_UINT128.toFixed(),
      })
      .then((res) => {
        return res;
      })
      .catch((e) => {
        return { amount0: 0, amount1: 0 };
      });
    return {
      positionId: tokenId,
      tickLower: position.tickLower,
      tickUpper: position.tickUpper,
      liquidity: position.liquidity,
      tokensOwed0: new BN(tokenCollectFees.amount0.toString()).div(
        new BN(10).pow(token0.decimals)
      ),
      tokensOwed1: new BN(tokenCollectFees.amount1.toString()).div(
        new BN(10).pow(token1.decimals)
      ),
      token0: position.token0,
      token1: position.token1,
      fee: position.fee,
      tokenAmount0: new BN(amount0.toString()).div(
        new BN(10).pow(token0.decimals)
      ),
      tokenAmount1: new BN(amount1.toString()).div(
        new BN(10).pow(token1.decimals)
      ),
      currentPrice: currentPrice,
      lowerRangePrice,
      upperRangePrice,
    };
  }

  /**
   * Mint a position in the liquidity pool.
   *
   * @param token0 - The first token of the liquidity pair.
   * @param token0Amount - The amount of the first token to be minted.
   * @param token1 - The second token of the liquidity pair.
   * @param token1Amount - The amount of the second token to be minted.
   * @param pool - The liquidity pool.
   * @param createPool - A boolean indicating whether to create the pool if it doesn't exist.
   * @param lowerRange - The lower price range for the position. Optional.
   * @param upperRange - The upper price range for the position. Optional.
   * @returns A promise that resolves to the method parameters for minting the position.
   */
  public async mintPosition(
    token0: Token,
    token0Amount: number,
    token1: Token,
    token1Amount: number,
    pool: Pool,
    createPool: boolean,
    lowerRange?: number,
    upperRange?: number,
    gasPrice?: BigNumber
  ): Promise<MethodParameters> {
    const address = await this.signer.getAddress();
    const provider = this.signer.provider;

    if (!address || !provider) {
      throw Error("No address or provider");
    }

    // Give approval to the Position Manager contract to transfer tokens
    await this.getTokenTransferApproval(
      token0,
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      ethers.utils.parseUnits(token0Amount.toString(), token0.decimals),
      false,
      gasPrice
    );
    await this.getTokenTransferApproval(
      token1,
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      ethers.utils.parseUnits(token1Amount.toString(), token1.decimals),
      false,
      gasPrice
    );

    let tickLower: number;
    let tickUpper: number;

    const token0Decimals = token0.decimals;
    const token1Decimals = token1.decimals;
    const isSorted = token0.sortsBefore(token1);

    if (lowerRange) {
      // const priceTick = Math.floor(Math.log(lowerRange) / Math.log(1.0001));
      // tickLower = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
      const priceTick = Math.floor(
        Math.log(lowerRange / 10 ** (token0Decimals - token1Decimals)) /
          Math.log(1.0001)
      );
      tickLower = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
    } else {
      tickLower = nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[pool.fee]);
    }

    if (upperRange) {
      // const priceTick = Math.floor(Math.log(upperRange) / Math.log(1.0001));
      // tickUpper = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
      const priceTick = Math.floor(
        Math.log(upperRange / 10 ** (token0Decimals - token1Decimals)) /
          Math.log(1.0001)
      );
      tickUpper = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
    } else {
      tickUpper = nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[pool.fee]);
    }

    const positionToMint = await this.constructPosition(
      CurrencyAmount.fromRawAmount(
        token0,
        fromReadableAmount(token0Amount, token0.decimals)
      ),
      CurrencyAmount.fromRawAmount(
        token1,
        fromReadableAmount(token1Amount, token1.decimals)
      ),
      pool,
      tickLower,
      tickUpper
    );

    let mintOptions: MintOptions;
    if (
      token0.address == WETH[this.chainId].address ||
      token1.address == WETH[this.chainId].address
    ) {
      mintOptions = {
        recipient: address,
        deadline: Math.floor(Date.now() / 1000) + 60 * 20,
        slippageTolerance: new Percent(50, 10_000),
        createPool,
        useNative: Ether.onChain(this.chainId),
      };
    } else {
      mintOptions = {
        recipient: address,
        deadline: Math.floor(Date.now() / 1000) + 60 * 20,
        slippageTolerance: new Percent(50, 10_000),
        createPool,
      };
    }

    // get calldata for minting a position
    const payload = NonfungiblePositionManager.addCallParameters(
      positionToMint,
      mintOptions
    );

    return payload;
  }

  /**
   * Increases a position by providing additional liquidity.
   * @param positionId - The ID of the position to increase.
   * @param token0 - The first token of the position.
   * @param token0Amount - The amount of the first token to add to the position.
   * @param token1 - The second token of the position.
   * @param token1Amount - The amount of the second token to add to the position.
   * @returns A promise that resolves to the method parameters for increasing the position.
   */
  public async increasePosition(
    positionId: number,
    token0: Token,
    token0Amount: number,
    token1: Token,
    token1Amount: number,
    gasPrice?: BigNumber
  ): Promise<MethodParameters> {
    const positionInfo = await this.getPositionInfo(positionId);
    if (!positionInfo) {
      throw Error("No position info");
    }
    const pool = await getPoolData(
      CurrencyAmount.fromRawAmount(
        token0,
        new BN(positionInfo.tokenAmount0.toString())
          .multipliedBy(new BN(10).pow(token0.decimals))
          .toFixed()
      ),
      CurrencyAmount.fromRawAmount(
        token1,
        new BN(positionInfo.tokenAmount1.toString())
          .multipliedBy(new BN(10).pow(token1.decimals))
          .toFixed()
      ),
      positionInfo.fee,
      this.signer.provider,
      this.chainId
    );
    // Give approval to the Position Manager contract to transfer tokens
    await this.getTokenTransferApproval(
      token0,
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      ethers.utils.parseUnits(
        formatAmount(token0Amount.toString(), token0.decimals),
        token0.decimals
      ),
      token0.address.toLowerCase() === WETH[this.chainId].address.toLowerCase(),
      gasPrice
    );
    await this.getTokenTransferApproval(
      token1,
      NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
      ethers.utils.parseUnits(
        formatAmount(token1Amount.toString(), token1.decimals),
        token1.decimals
      ),
      token1.address.toLowerCase() === WETH[this.chainId].address.toLowerCase(),
      gasPrice
    );

    const positionToIncreaseBy = await this.constructPosition(
      CurrencyAmount.fromRawAmount(
        token0,
        fromReadableAmount(
          Number(formatAmount(token0Amount.toString(), token0.decimals)),
          token0.decimals
        )
      ),
      CurrencyAmount.fromRawAmount(
        token1,
        fromReadableAmount(
          Number(formatAmount(token1Amount.toString(), token1.decimals)),
          token1.decimals
        )
      ),
      pool.pool,
      positionInfo.tickLower,
      positionInfo.tickUpper
    );

    const addLiquidityOptions: AddLiquidityOptions = {
      deadline: Math.floor(Date.now() / 1000) + 60 * 20,
      slippageTolerance: new Percent(50, 10_000),
      tokenId: positionId,
    };

    // get calldata for increasing a position
    const payload = NonfungiblePositionManager.addCallParameters(
      positionToIncreaseBy,
      addLiquidityOptions
    );

    return payload;
  }

  /**
   * Retrieves the token transfer approval for a given token and spender address.
   * If the token is WETH or `approveWeth` is set to true, it approves the spender address to spend the maximum amount of tokens.
   * Otherwise, it checks if the current allowance is already enough and if not, approves the spender address to spend the maximum amount of tokens.
   * @param token The token for which to retrieve the transfer approval.
   * @param spenderAddress The address of the spender.
   * @param amount The amount of tokens to approve. Defaults to `ethers.constants.MaxUint256`.
   * @param approveWeth Whether to approve the spender address for WETH token. Defaults to `false`.
   * @returns A promise that resolves to the transaction receipt once the approval is complete.
   * @throws Error if there is no provider or address.
   */
  public async getTokenTransferApproval(
    token: Token,
    spenderAddress: string,
    amount: BigNumber = ethers.constants.MaxUint256,
    approveWeth = false,
    gasPrice?: BigNumber
  ) {
    if (approveWeth || token.address != WETH[this.chainId].address) {
      const provider = this.signer.provider;
      const address = await this.signer.getAddress();
      if (!provider || !address) {
        throw Error("No provider or address");
      }

      try {
        const tokenContract = new ethers.Contract(
          token.address,
          ERC20_ABI,
          provider
        );

        // Check if the allowance is already enough
        const allowance = await tokenContract.allowance(
          address,
          spenderAddress
        );
        if (allowance.gte(amount)) {
          return;
        }
        const transaction = await tokenContract
          .connect(this.signer)
          .approve(spenderAddress, ethers.constants.MaxUint256, {
            maxFeePerGas: MAX_FEE_PER_GAS[this.chainId],
            maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS[this.chainId],
            gasPrice: gasPrice,
          });
        return transaction.wait();
      } catch (e) {
        throw e;
      }
    }
  }

  /**
   * Constructs a position using the provided token amounts, pool configuration, and tick range.
   * @param token0Amount The amount of token0.
   * @param token1Amount The amount of token1.
   * @param configuredPool The configured pool.
   * @param tickLower The lower tick of the position.
   * @param tickUpper The upper tick of the position.
   * @returns A Promise that resolves to the constructed Position.
   * @throws Error if no provider is available.
   */
  public async constructPosition(
    token0Amount: CurrencyAmount<Token>,
    token1Amount: CurrencyAmount<Token>,
    configuredPool: Pool,
    tickLower: number,
    tickUpper: number
  ): Promise<Position> {
    if (!this.signer.provider) {
      throw new Error("No provider");
    }

    // create position using the maximum liquidity from input amounts
    return Position.fromAmounts({
      pool: configuredPool,
      // tickLower: -TICK_SPACINGS[fee],
      // tickUpper: TICK_SPACINGS[fee],
      tickLower,
      tickUpper,
      amount0: token0Amount.quotient,
      amount1: token1Amount.quotient,
      useFullPrecision: true,
    });
  }

  /**
   * Returns the quote token based on the given input and output tokens and trade type.
   * @param tokenIn The input token.
   * @param tokenOut The output token.
   * @param tradeType The type of trade.
   * @returns The quote token.
   */
  public getQuoteToken = (
    tokenIn: Currency,
    tokenOut: Currency,
    tradeType: TradeType
  ): Currency => {
    return tradeType == TradeType.EXACT_INPUT ? tokenOut : tokenIn;
  };

  /**
   * Performs a swap between two tokens.
   *
   * @param tokenIn The input token.
   * @param tokenOut The output token.
   * @param tradeType The type of trade.
   * @param tokenAmount The amount of tokens to swap.
   * @param options Additional swap options.
   * @returns The swap transaction.
   * @throws Error if the slippage tolerance is invalid or the deadline is in the past.
   */
  public async swap(
    tokenIn: Token,
    tokenOut: Token,
    tradeType: TradeType,
    tokenAmount: string,
    options?: SwapOptions,
    gasPrice?: BigNumber
  ) {
    if (
      options.slippage &&
      (typeof options.slippage !== "number" ||
        (options.slippage > 0 && options.slippage < 0))
    ) {
      throw Error("Slippage tolerance between 0 to 100");
    }
    if (
      options.deadline &&
      (typeof options.deadline !== "number" ||
        options.deadline < Date.now() / 1000 + 60)
    ) {
      throw Error("Deadline should not be of past value");
    }
    let tokenInput: Currency = tokenIn;
    let tokenOutput: Currency = tokenOut;
    if (
      tokenIn.address.toLowerCase() == WETH[this.chainId].address.toLowerCase()
    ) {
      tokenInput = Ether.onChain(this.chainId);
    }

    if (
      tokenOut.address.toLowerCase() == WETH[this.chainId].address.toLowerCase()
    ) {
      tokenOutput = Ether.onChain(this.chainId);
    }

    const amount =
      tradeType == TradeType.EXACT_INPUT
        ? parseAmount(
            formatAmount(tokenAmount, tokenInput.decimals),
            tokenInput
          )
        : parseAmount(
            formatAmount(tokenAmount, tokenOutput.decimals),
            tokenOutput
          );
    const provider = new ethers.providers.JsonRpcProvider(
      RPC_URL[this.chainId]
    );
    const router = new AlphaRouter({
      chainId: this.chainId,
      provider: provider as ethers.providers.BaseProvider,
    });

    if (!tokenInput.isNative) {
      await this.getTokenTransferApproval(
        tokenIn as Token,
        SMART_ROUTER_ADDRESS[this.chainId],
        ethers.utils.parseUnits(tokenAmount.toString(), tokenIn.decimals),
        false,
        gasPrice
      );
    }

    const swap = await router.route(
      amount,
      this.getQuoteToken(tokenInput, tokenOutput, tradeType),
      tradeType,
      {
        type: SwapType.SWAP_ROUTER_02,
        slippageTolerance: new Percent(
          Math.floor((options?.slippage ?? 0.5) * 10_000),
          10_000
        ),
        recipient: await this.signer.getAddress(),
        deadline: options?.deadline
          ? Math.floor(options.deadline)
          : Math.floor(Date.now() / 1000) + 60 * 20,
      },
      {
        protocols: [Protocol.V3],
        ...(this.chainId === ChainId.MOVEMENT_TESTNET
          ? { distributionPercent: 100 }
          : {}),
      }
    );
    return swap;
  }

  /**
   * Retrieves a quote for a trade between two tokens.
   * @param tokenIn The input token for the trade.
   * @param tokenOut The output token for the trade.
   * @param tradeType The type of trade (exact input or exact output).
   * @param tokenAmount The amount of tokens to be traded.
   * @param slippage The maximum acceptable slippage for the trade.
   * @returns An object containing the exchange rate, price impact, and route of the trade.
   */
  public async getQuote(
    tokenIn: Token,
    tokenOut: Token,
    tradeType: TradeType,
    tokenAmount: string,
    slippage: number
  ) {
    let tokenInput: Currency = tokenIn;
    let tokenOutput: Currency = tokenOut;
    if (tokenIn.address == WETH[this.chainId].address) {
      tokenInput = Ether.onChain(this.chainId);
    }

    if (tokenOut.address == WETH[this.chainId].address) {
      tokenOutput = Ether.onChain(this.chainId);
    }
    const slippagePercent = new Percent(
      Math.floor((slippage ?? 0.5) * 10_000),
      10_000
    );

    const amount =
      tradeType == TradeType.EXACT_INPUT
        ? parseAmount(
            formatAmount(tokenAmount, tokenInput.decimals),
            tokenInput
          )
        : parseAmount(
            formatAmount(tokenAmount, tokenOutput.decimals),
            tokenOutput
          );

    const provider = new ethers.providers.JsonRpcProvider(
      RPC_URL[this.chainId]
    );
    const router = new AlphaRouter({
      chainId: this.chainId,
      provider: provider as ethers.providers.BaseProvider,
    });

    const swap = await router.route(
      amount,
      this.getQuoteToken(tokenInput, tokenOutput, tradeType),
      tradeType,
      {
        type: SwapType.SWAP_ROUTER_02,
        slippageTolerance: slippagePercent,
        recipient: await this.signer.getAddress(),
        deadline: Math.floor(Date.now() / 1000) + 60 * 20,
      },
      {
        protocols: [Protocol.V3],
        ...(this.chainId === ChainId.MOVEMENT_TESTNET
          ? { distributionPercent: 100 }
          : {}),
      }
    );

    const exchangeRate =
      tradeType == TradeType.EXACT_INPUT
        ? swap?.trade?.executionPrice?.toSignificant()
        : swap?.trade?.executionPrice?.invert()?.toSignificant();
    const priceImpact = swap.trade.priceImpact.toSignificant();
    const route = swap.trade.routes;

    return {
      exchangeRate,
      priceImpact,
      route,
    };
  }

  /**
   * Constructs a position with placeholder liquidity.
   *
   * @param token0 - The first token of the pool.
   * @param token1 - The second token of the pool.
   * @param poolFee - The fee amount of the pool.
   * @returns A promise that resolves to a Position object.
   */
  public async constructPositionWithPlaceholderLiquidity(
    token0: Token,
    token1: Token,
    poolFee: FeeAmount
  ): Promise<Position> {
    // get pool info
    const poolInfo = await getPoolInfo(
      token0,
      token1,
      poolFee,
      this.signer.provider,
      this.chainId
    );

    // construct pool instance
    const configuredPool = new Pool(
      token0,
      token1,
      poolInfo.fee,
      poolInfo.sqrtPriceX96.toString(),
      poolInfo.liquidity.toString(),
      poolInfo.tick
    );

    // create position using the maximum liquidity from input amounts
    return new Position({
      pool: configuredPool,
      tickLower:
        nearestUsableTick(poolInfo.tick, poolInfo.tickSpacing) -
        poolInfo.tickSpacing * 2,
      tickUpper:
        nearestUsableTick(poolInfo.tick, poolInfo.tickSpacing) +
        poolInfo.tickSpacing * 2,
      liquidity: 1,
    });
  }

  /**
   * Collects fees for a given position.
   * @param positionId - The ID of the position.
   * @param token0 - The first token of the position.
   * @param token1 - The second token of the position.
   * @param recipient - The address where the collected fees will be sent to.
   * @returns A promise that resolves to the method parameters for collecting fees.
   */
  public async collectFees(
    positionId: number,
    token0: Token,
    token1: Token,
    recipient: string
  ): Promise<MethodParameters> {
    const collectOptions: CollectOptions = {
      tokenId: positionId,
      expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(token0, 0),
      expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(token1, 0),
      recipient,
    };

    // get calldata for minting a position
    const payload =
      NonfungiblePositionManager.collectCallParameters(collectOptions);

    return payload;
  }

  /**
   * Removes liquidity from a position.
   *
   * @param positionId - The ID of the position.
   * @param token0 - The first token in the liquidity pair.
   * @param token1 - The second token in the liquidity pair.
   * @param percent - The percentage of liquidity to remove.
   * @param recipient - The address where the removed liquidity will be sent.
   * @returns A Promise that resolves to the method parameters for removing liquidity.
   */
  public async removeLiquidity(
    positionId: number,
    token0: Token,
    token1: Token,
    percent: number,
    recipient: string
  ): Promise<MethodParameters> {
    const positionInfo = await this.getPositionInfo(positionId);
    const currencyAmount0 = CurrencyAmount.fromRawAmount(
      token0,
      new BN(positionInfo.tokenAmount0.toString())
        .multipliedBy(new BN(10).pow(token0.decimals))
        .toFixed()
    );

    const currencyAmount1 = CurrencyAmount.fromRawAmount(
      token1,
      new BN(positionInfo.tokenAmount1.toString())
        .multipliedBy(new BN(10).pow(token1.decimals))
        .toFixed()
    );

    const poolInfo = await getPoolInfo(
      currencyAmount0.currency,
      currencyAmount1.currency,
      positionInfo.fee,
      this.signer.provider,
      this.chainId
    );

    const pool = new Pool(
      currencyAmount0.currency,
      currencyAmount1.currency,
      poolInfo.fee,
      poolInfo.sqrtPriceX96.toString(),
      Number(poolInfo.liquidity.toString()) === 0
        ? positionInfo.liquidity.toString()
        : poolInfo.liquidity.toString(),
      poolInfo.tick
    );

    const currentPosition = await this.constructPosition(
      currencyAmount0,
      currencyAmount1,
      pool,
      positionInfo.tickLower,
      positionInfo.tickUpper
    );

    const collectOptions: Omit<CollectOptions, "tokenId"> = {
      expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(token0, 0),
      expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(token1, 0),
      recipient,
    };

    const removeLiquidityOptions: RemoveLiquidityOptions = {
      deadline: Math.floor(Date.now() / 1000) + 60 * 20,
      slippageTolerance: new Percent(50, 10_000),
      tokenId: positionId,
      // percentage of liquidity to remove
      liquidityPercentage: new Percent(Math.floor(percent * 10_000), 10_000),
      collectOptions,
    };
    // get calldata for minting a position
    const payload = NonfungiblePositionManager.removeCallParameters(
      currentPosition,
      removeLiquidityOptions
    );

    return payload;
  }

  /**
   * Wraps the native token by depositing the specified amount into the WETH contract.
   * @param amount - The amount of native token to wrap.
   * @returns A promise that resolves to the transaction object.
   */
  public async wrapNativeToken(amount: string): Promise<any> {
    const wethContract = new ethers.Contract(
      WETH[this.chainId].address,
      WETH_ABI,
      this.signer
    );

    const tx = await wethContract.deposit({
      value: ethers.utils.parseEther(formatAmount(amount, 18)),
      maxFeePerGas: MAX_FEE_PER_GAS[this.chainId],
      maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS[this.chainId],
    });

    return tx;
  }

  /**
   * Unwraps the native token by withdrawing the specified amount from the WETH contract.
   * @param amount - The amount of native token to unwrap.
   * @returns A promise that resolves to the transaction object.
   */
  public async unwrapNativeToken(amount: string): Promise<any> {
    const wethContract = new ethers.Contract(
      WETH[this.chainId].address,
      WETH_ABI,
      this.signer
    );

    const tx = await wethContract.withdraw(
      ethers.utils.parseEther(formatAmount(amount, 18)),
      {
        maxFeePerGas: MAX_FEE_PER_GAS[this.chainId],
        maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS[this.chainId],
      }
    );

    return tx;
  }
}
