import { ethers } from "ethers";
import IUniswapV3PoolABI from "@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json";
import { ChainId, DEPLOYER_ADDRESS, POOL_INIT_CODE_HASH } from "./constants";
import {
  computePoolAddress,
  encodeSqrtRatioX96,
  FeeAmount,
  nearestUsableTick,
  Pool,
  Position,
  TICK_SPACINGS,
} from "@warpgatex/warp-v3-sdk";
import { Token, CurrencyAmount } from "@uniswap/sdk-core";
import { TickMath } from "@warpgatex/warp-v3-sdk";
import BigNumber from "bignumber.js";

export interface PoolInfo {
  token0: string;
  token1: string;
  fee: number;
  tickSpacing: number;
  sqrtPriceX96: ethers.BigNumber;
  liquidity: ethers.BigNumber;
  tick: number;
  currentPrice: number;
}

/**
 * Retrieves information about a pool.
 * @param tokenA - The first token in the pool.
 * @param tokenB - The second token in the pool.
 * @param poolFee - The fee amount for the pool.
 * @param provider - The Ethereum provider.
 * @param chainId - The chain ID.
 * @returns A Promise that resolves to the pool information or null if the pool does not exist.
 * @throws An error if no provider is provided.
 */
export async function getPoolInfo(
  tokenA: Token,
  tokenB: Token,
  poolFee: FeeAmount,
  provider: ethers.providers.Provider,
  chainId: number
): Promise<PoolInfo | null> {
  if (!provider) {
    throw new Error("No provider");
  }
  if (!Object.values(ChainId).includes(Number(chainId))) {
    throw new Error("Invalid Chain ID");
  }
  const currentPoolAddress = computePoolAddress({
    factoryAddress: DEPLOYER_ADDRESS[chainId],
    tokenA: tokenA,
    tokenB: tokenB,
    fee: poolFee,
    initCodeHashManualOverride: POOL_INIT_CODE_HASH[chainId],
  });
  console.log("currentPoolAddress: ", currentPoolAddress);
  //check if current pool exists
  const code = await provider.getCode(currentPoolAddress);
  if (code === "0x") {
    return null;
  }

  const poolContract = new ethers.Contract(
    currentPoolAddress,
    IUniswapV3PoolABI.abi,
    provider
  );

  const [token0, token1, fee, tickSpacing, liquidity, slot0] =
    await Promise.all([
      poolContract.token0(),
      poolContract.token1(),
      poolContract.fee(),
      poolContract.tickSpacing(),
      poolContract.liquidity(),
      poolContract.slot0(),
    ]);

  const currentTick = slot0[1];

  const currentPrice =
    tokenA.address == token0
      ? 1.0001 ** currentTick * 10 ** (tokenA.decimals - tokenB.decimals)
      : 1.0001 ** -currentTick * 10 ** (tokenA.decimals - tokenB.decimals);

  return {
    token0,
    token1,
    fee,
    tickSpacing,
    liquidity,
    sqrtPriceX96: slot0[0],
    tick: slot0[1],
    currentPrice,
  };
}

/**
 * Retrieves the pool data for a given pair of tokens and pool fee.
 * If the pool does not exist, it creates a new pool with the provided tokens and fee.
 *
 * @param token0 - The first token in the pair.
 * @param token1 - The second token in the pair.
 * @param poolFee - The fee amount for the pool.
 * @param provider - The ethers provider used to interact with the blockchain.
 * @param chainId - The chain ID.
 * @returns An object containing the pool data and a flag indicating whether the pool was created.
 * @throws If there is an error retrieving or creating the pool.
 */
export async function getPoolData(
  token0: CurrencyAmount<Token>,
  token1: CurrencyAmount<Token>,
  poolFee: FeeAmount,
  provider: ethers.providers.Provider,
  chainId: number
) {
  if (!Object.values(ChainId).includes(Number(chainId))) {
    throw new Error("Invalid Chain ID");
  }
  try {
    const poolInfo = await getPoolInfo(
      token0.currency,
      token1.currency,
      poolFee,
      provider,
      chainId
    );
    let pool: Pool;
    if (!poolInfo) {
      const currentTick = TickMath.getTickAtSqrtRatio(
        encodeSqrtRatioX96(token1.quotient, token0.quotient)
      );
      pool = new Pool(
        token0.currency,
        token1.currency,
        poolFee,
        encodeSqrtRatioX96(token1.quotient, token0.quotient).toString(),
        "0",
        currentTick
      );
      return { pool, createPool: true };
    } else {
      pool = new Pool(
        token0.currency,
        token1.currency,
        poolInfo.fee,
        poolInfo.sqrtPriceX96.toString(),
        poolInfo.liquidity.toString(),
        poolInfo.tick
      );
      return { pool, createPool: false };
    }
  } catch (err) {
    console.debug(err);
    throw err;
  }
}

/**
 * Computes the token amount for liquidity based on the given parameters.
 *
 * @param token0 - The first token in the pool.
 * @param token1 - The second token in the pool.
 * @param amount - The amount of liquidity.
 * @param poolFee - The fee amount for the pool.
 * @param currentPrice - The current price of the pool.
 * @param output - The desired output token ("token0" or "token1").
 * @param lowerPrice - The lower price limit.
 * @param upperPrice - The upper price limit.
 * @returns The computed output amount.
 */
export const computeTokenAmountForLiquidity = (
  token0: Token,
  token1: Token,
  amount: number,
  poolFee: FeeAmount,
  currentPrice: number,
  output: "token0" | "token1" = "token0",
  lowerPrice?: number,
  upperPrice?: number
) => {
  const currentTick = nearestUsableTick(
    Math.floor(Math.log(currentPrice) / Math.log(1.0001)),
    TICK_SPACINGS[poolFee]
  );

  let tickLower: number;
  let tickUpper: number;

  if (lowerPrice) {
    const priceTick = Math.floor(Math.log(lowerPrice) / Math.log(1.0001));
    tickLower = nearestUsableTick(priceTick, TICK_SPACINGS[poolFee]);
  } else {
    tickLower = nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[poolFee]);
  }

  if (upperPrice) {
    const priceTick = Math.floor(Math.log(upperPrice) / Math.log(1.0001));
    tickUpper = nearestUsableTick(priceTick, TICK_SPACINGS[poolFee]);
  } else {
    tickUpper = nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[poolFee]);
  }

  const pool = new Pool(
    token0,
    token1,
    poolFee,
    TickMath.getSqrtRatioAtTick(currentTick),
    "0",
    currentTick
  );
  const amountReq = new BigNumber(amount)
    .multipliedBy(
      new BigNumber(10).pow((output === "token0" ? token1 : token0).decimals)
    )
    .toFixed();

  const position =
    output === "token1"
      ? Position.fromAmount0({
          pool,
          tickLower,
          tickUpper,
          amount0: amountReq,
          useFullPrecision: true,
        })
      : Position.fromAmount1({
          pool,
          tickLower,
          tickUpper,
          amount1: amountReq,
        });

  const outputAmount =
    output === "token0"
      ? position.amount0.toFixed()
      : position.amount1.toFixed();
  return outputAmount;
};
