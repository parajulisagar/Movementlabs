"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextPrice = exports.getAdjustedPrice = exports.getWalletTokenBalance = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const warp_v3_sdk_1 = require("@warpgatex/warp-v3-sdk");
/**
 * Retrieves the token balance of a wallet for multiple token addresses.
 * @param tokenAddresses - An array of token addresses.
 * @param owner - An array of wallet addresses.
 * @param provider - The ethers provider used to interact with the blockchain.
 * @returns An object containing the token balances for each wallet address.
 */
function getWalletTokenBalance(tokenAddresses, owner, provider, chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Object.values(constants_1.ChainId).includes(Number(chainId))) {
            throw new Error("Invalid Chain ID");
        }
        const contract = new ethers_1.ethers.Contract(constants_1.MULTICALL_CONTRACT_ADDRESS[chainId], constants_1.MULTICALL_ABI, provider);
        const calls = [];
        owner.forEach((walletAddress) => {
            tokenAddresses.forEach((tokenAddress) => {
                if (tokenAddress == ethers_1.ethers.constants.AddressZero) {
                    calls.push({
                        target: constants_1.MULTICALL_CONTRACT_ADDRESS[chainId],
                        callData: contract.interface.encodeFunctionData("getEthBalance", [
                            walletAddress,
                        ]),
                        allowFailure: true,
                    });
                }
                else {
                    const tokenContract = new ethers_1.ethers.Contract(tokenAddress, constants_1.ERC20_ABI, provider);
                    calls.push({
                        target: tokenAddress,
                        callData: tokenContract.interface.encodeFunctionData("balanceOf", [
                            walletAddress,
                        ]),
                        allowFailure: true,
                    });
                }
            });
        });
        const result = yield contract.callStatic.aggregate3(calls);
        const parsedResult = result.map((res) => {
            const iface = new ethers_1.ethers.utils.Interface(constants_1.ERC20_ABI);
            const decoded = iface.decodeFunctionResult("balanceOf", res.returnData);
            return decoded[0];
        });
        const numOwners = owner.length;
        let returnObj = {};
        for (let i = 0; i < numOwners; i++) {
            const offset = parsedResult.length / numOwners;
            returnObj[owner[i]] = parsedResult.slice(i * offset, (i + 1) * offset);
        }
        return returnObj;
    });
}
exports.getWalletTokenBalance = getWalletTokenBalance;
/**
 * Calculates the adjusted price based on the given price and fee amount.
 * @param price - The original price.
 * @param fee - The fee amount.
 * @returns The adjusted price.
 */
const getAdjustedPrice = (price, fee) => {
    const priceTick = Math.floor(Math.log(price) / Math.log(1.0001));
    const tick = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[fee]);
    const adjustedPrice = Math.pow(1.0001, tick);
    return Number(adjustedPrice.toFixed(6));
};
exports.getAdjustedPrice = getAdjustedPrice;
/**
 * Calculates the next price based on the current price, fee amount, and increment.
 *
 * @param price - The current price.
 * @param fee - The fee amount.
 * @param incr - The increment value.
 * @returns The next price.
 */
const getNextPrice = (price, fee, incr) => {
    const priceTick = Math.floor(Math.log(price) / Math.log(1.0001));
    const tick = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[fee]);
    const adjustedPrice = Math.pow(1.0001, tick + incr * (fee / 50));
    return Number(adjustedPrice.toFixed(6));
};
exports.getNextPrice = getNextPrice;
