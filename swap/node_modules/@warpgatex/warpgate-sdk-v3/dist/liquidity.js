"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.liquidityClient = exports.TransactionState = void 0;
const IUniswapV3Pool_json_1 = __importDefault(require("@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json"));
const ethers_1 = require("ethers");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
const warp_v3_sdk_1 = require("@warpgatex/warp-v3-sdk");
const v3_sdk_1 = require("@pancakeswap/v3-sdk");
const sdk_core_1 = require("@uniswap/sdk-core");
const conversion_1 = require("./conversion");
const pool_1 = require("./pool");
const warp_smart_order_router_1 = require("@warpgatex/warp-smart-order-router");
const ether_1 = require("./ether");
const router_sdk_1 = require("@uniswap/router-sdk");
const token_1 = require("./token");
var TransactionState;
(function (TransactionState) {
    TransactionState["Failed"] = "Failed";
    TransactionState["New"] = "New";
    TransactionState["Rejected"] = "Rejected";
    TransactionState["Sending"] = "Sending";
    TransactionState["Sent"] = "Sent";
})(TransactionState || (exports.TransactionState = TransactionState = {}));
/**
 * Represents a liquidity client that interacts with the liquidity-related functionality of the SDK.
 */
class liquidityClient {
    constructor(signer, chainId) {
        /**
         * Returns the quote token based on the given input and output tokens and trade type.
         * @param tokenIn The input token.
         * @param tokenOut The output token.
         * @param tradeType The type of trade.
         * @returns The quote token.
         */
        this.getQuoteToken = (tokenIn, tokenOut, tradeType) => {
            return tradeType == sdk_core_1.TradeType.EXACT_INPUT ? tokenOut : tokenIn;
        };
        if (!Object.values(constants_1.ChainId).includes(Number(chainId))) {
            throw new Error("Invalid Chain ID");
        }
        this.signer = signer;
        this.chainId = chainId;
    }
    /**
     * Re-initializes the signer and chain ID.
     * @param signer - The signer to use for the client.
     * @param chainId - The chain ID.
     */
    reinitialize(signer, chainId) {
        this.signer = signer;
        this.chainId = chainId;
    }
    /**
     * Retrieves the position IDs associated with the given address.
     *
     * @param address - The address for which to retrieve the position IDs.
     * @param chainId - The chain ID.
     * @returns An array of position IDs.
     */
    getPositionIds(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const positionContract = new ethers_1.ethers.Contract(constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], constants_1.NONFUNGIBLE_POSITION_MANAGER_ABI, this.signer.provider);
            // Get number of positions
            const balance = yield positionContract.balanceOf(address);
            const multicallContract = new ethers_1.ethers.Contract(constants_1.MULTICALL_CONTRACT_ADDRESS[this.chainId], constants_1.MULTICALL_ABI, this.signer.provider);
            const calls = [];
            for (let i = 0; i < balance; i++) {
                const calldata = positionContract.interface.encodeFunctionData("tokenOfOwnerByIndex", [address, i]);
                calls.push({
                    target: constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId],
                    callData: calldata,
                    allowFailure: false,
                });
            }
            const tokenIds = yield multicallContract.callStatic.aggregate3(calls);
            return tokenIds.map((tokenId) => {
                return ethers_1.BigNumber.from(tokenId.returnData);
            });
        });
    }
    /**
     * Retrieves information about a specific position.
     * @param tokenId - The ID of the position.
     * @returns A Promise that resolves to a PositionInfo object containing the position details.
     */
    getPositionInfo(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const positionContract = new ethers_1.ethers.Contract(constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], constants_1.NONFUNGIBLE_POSITION_MANAGER_ABI, this.signer.provider);
            const position = yield positionContract.positions(tokenId);
            const token0Info = yield (0, token_1.getTokenInfo)(position.token0, this.chainId);
            const token1Info = yield (0, token_1.getTokenInfo)(position.token1, this.chainId);
            const token0 = new sdk_core_1.Token(this.chainId, position.token0, token0Info.decimals, "Token 0", "tIMX");
            const token1 = new sdk_core_1.Token(this.chainId, position.token1, token1Info.decimals, "Token 1", "USDC");
            const currentPoolAddress = (0, warp_v3_sdk_1.computePoolAddress)({
                factoryAddress: constants_1.DEPLOYER_ADDRESS[this.chainId],
                tokenA: token0,
                tokenB: token1,
                fee: position.fee,
                initCodeHashManualOverride: constants_1.POOL_INIT_CODE_HASH[this.chainId],
            });
            const poolContract = new ethers_1.ethers.Contract(currentPoolAddress, IUniswapV3Pool_json_1.default.abi, this.signer.provider);
            const [slot0] = yield Promise.all([poolContract.slot0()]);
            const tick = slot0[1];
            const sqrtRatioX96 = slot0[0];
            const isSorted = token0.sortsBefore(token1);
            const currentPrice = isSorted
                ? 1.0001 ** tick * 10 ** (token0Info.decimals - token1Info.decimals)
                : 1.0001 ** -tick * 10 ** (token0Info.decimals - token1Info.decimals);
            const amount0 = v3_sdk_1.PositionMath.getToken0Amount(tick, position.tickLower, position.tickUpper, BigInt(sqrtRatioX96.toString()), BigInt(position.liquidity.toString()));
            const amount1 = v3_sdk_1.PositionMath.getToken1Amount(tick, position.tickLower, position.tickUpper, BigInt(sqrtRatioX96.toString()), BigInt(position.liquidity.toString()));
            // const lowerRangePrice = 1.0001 ** position.tickLower;
            // const upperRangePrice = 1.0001 ** position.tickUpper;
            const lowerRangePrice = isSorted
                ? 1.0001 ** position.tickLower *
                    10 ** (token0Info.decimals - token1Info.decimals)
                : 1.0001 ** -position.tickLower *
                    10 ** (token0Info.decimals - token1Info.decimals);
            const upperRangePrice = isSorted
                ? 1.0001 ** position.tickUpper *
                    10 ** (token0Info.decimals - token1Info.decimals)
                : 1.0001 ** -position.tickUpper *
                    10 ** (token0Info.decimals - token1Info.decimals);
            const MAX_UINT128 = new bignumber_js_1.default(2).pow(128).minus(1);
            const recipient = yield this.signer.getAddress();
            // TODO: Fix callStatic on collect for movement contracts
            const tokenCollectFees = yield positionContract.callStatic
                .collect({
                tokenId,
                recipient,
                amount0Max: MAX_UINT128.toFixed(),
                amount1Max: MAX_UINT128.toFixed(),
            })
                .then((res) => {
                return res;
            })
                .catch((e) => {
                return { amount0: 0, amount1: 0 };
            });
            return {
                positionId: tokenId,
                tickLower: position.tickLower,
                tickUpper: position.tickUpper,
                liquidity: position.liquidity,
                tokensOwed0: new bignumber_js_1.default(tokenCollectFees.amount0.toString()).div(new bignumber_js_1.default(10).pow(token0.decimals)),
                tokensOwed1: new bignumber_js_1.default(tokenCollectFees.amount1.toString()).div(new bignumber_js_1.default(10).pow(token1.decimals)),
                token0: position.token0,
                token1: position.token1,
                fee: position.fee,
                tokenAmount0: new bignumber_js_1.default(amount0.toString()).div(new bignumber_js_1.default(10).pow(token0.decimals)),
                tokenAmount1: new bignumber_js_1.default(amount1.toString()).div(new bignumber_js_1.default(10).pow(token1.decimals)),
                currentPrice: currentPrice,
                lowerRangePrice,
                upperRangePrice,
            };
        });
    }
    /**
     * Mint a position in the liquidity pool.
     *
     * @param token0 - The first token of the liquidity pair.
     * @param token0Amount - The amount of the first token to be minted.
     * @param token1 - The second token of the liquidity pair.
     * @param token1Amount - The amount of the second token to be minted.
     * @param pool - The liquidity pool.
     * @param createPool - A boolean indicating whether to create the pool if it doesn't exist.
     * @param lowerRange - The lower price range for the position. Optional.
     * @param upperRange - The upper price range for the position. Optional.
     * @returns A promise that resolves to the method parameters for minting the position.
     */
    mintPosition(token0, token0Amount, token1, token1Amount, pool, createPool, lowerRange, upperRange, gasPrice) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.signer.getAddress();
            const provider = this.signer.provider;
            if (!address || !provider) {
                throw Error("No address or provider");
            }
            // Give approval to the Position Manager contract to transfer tokens
            yield this.getTokenTransferApproval(token0, constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], ethers_1.ethers.utils.parseUnits(token0Amount.toString(), token0.decimals), false, gasPrice);
            yield this.getTokenTransferApproval(token1, constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], ethers_1.ethers.utils.parseUnits(token1Amount.toString(), token1.decimals), false, gasPrice);
            let tickLower;
            let tickUpper;
            const token0Decimals = token0.decimals;
            const token1Decimals = token1.decimals;
            const isSorted = token0.sortsBefore(token1);
            if (lowerRange) {
                // const priceTick = Math.floor(Math.log(lowerRange) / Math.log(1.0001));
                // tickLower = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
                const priceTick = Math.floor(Math.log(lowerRange / 10 ** (token0Decimals - token1Decimals)) /
                    Math.log(1.0001));
                tickLower = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[pool.fee]);
            }
            else {
                tickLower = (0, warp_v3_sdk_1.nearestUsableTick)(warp_v3_sdk_1.TickMath.MIN_TICK, warp_v3_sdk_1.TICK_SPACINGS[pool.fee]);
            }
            if (upperRange) {
                // const priceTick = Math.floor(Math.log(upperRange) / Math.log(1.0001));
                // tickUpper = nearestUsableTick(priceTick, TICK_SPACINGS[pool.fee]);
                const priceTick = Math.floor(Math.log(upperRange / 10 ** (token0Decimals - token1Decimals)) /
                    Math.log(1.0001));
                tickUpper = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[pool.fee]);
            }
            else {
                tickUpper = (0, warp_v3_sdk_1.nearestUsableTick)(warp_v3_sdk_1.TickMath.MAX_TICK, warp_v3_sdk_1.TICK_SPACINGS[pool.fee]);
            }
            const positionToMint = yield this.constructPosition(sdk_core_1.CurrencyAmount.fromRawAmount(token0, (0, conversion_1.fromReadableAmount)(token0Amount, token0.decimals)), sdk_core_1.CurrencyAmount.fromRawAmount(token1, (0, conversion_1.fromReadableAmount)(token1Amount, token1.decimals)), pool, tickLower, tickUpper);
            let mintOptions;
            if (token0.address == constants_1.WETH[this.chainId].address ||
                token1.address == constants_1.WETH[this.chainId].address) {
                mintOptions = {
                    recipient: address,
                    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
                    slippageTolerance: new sdk_core_1.Percent(50, 10000),
                    createPool,
                    useNative: ether_1.Ether.onChain(this.chainId),
                };
            }
            else {
                mintOptions = {
                    recipient: address,
                    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
                    slippageTolerance: new sdk_core_1.Percent(50, 10000),
                    createPool,
                };
            }
            // get calldata for minting a position
            const payload = warp_v3_sdk_1.NonfungiblePositionManager.addCallParameters(positionToMint, mintOptions);
            return payload;
        });
    }
    /**
     * Increases a position by providing additional liquidity.
     * @param positionId - The ID of the position to increase.
     * @param token0 - The first token of the position.
     * @param token0Amount - The amount of the first token to add to the position.
     * @param token1 - The second token of the position.
     * @param token1Amount - The amount of the second token to add to the position.
     * @returns A promise that resolves to the method parameters for increasing the position.
     */
    increasePosition(positionId, token0, token0Amount, token1, token1Amount, gasPrice) {
        return __awaiter(this, void 0, void 0, function* () {
            const positionInfo = yield this.getPositionInfo(positionId);
            if (!positionInfo) {
                throw Error("No position info");
            }
            const pool = yield (0, pool_1.getPoolData)(sdk_core_1.CurrencyAmount.fromRawAmount(token0, new bignumber_js_1.default(positionInfo.tokenAmount0.toString())
                .multipliedBy(new bignumber_js_1.default(10).pow(token0.decimals))
                .toFixed()), sdk_core_1.CurrencyAmount.fromRawAmount(token1, new bignumber_js_1.default(positionInfo.tokenAmount1.toString())
                .multipliedBy(new bignumber_js_1.default(10).pow(token1.decimals))
                .toFixed()), positionInfo.fee, this.signer.provider, this.chainId);
            // Give approval to the Position Manager contract to transfer tokens
            yield this.getTokenTransferApproval(token0, constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], ethers_1.ethers.utils.parseUnits((0, conversion_1.formatAmount)(token0Amount.toString(), token0.decimals), token0.decimals), token0.address.toLowerCase() === constants_1.WETH[this.chainId].address.toLowerCase(), gasPrice);
            yield this.getTokenTransferApproval(token1, constants_1.NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS[this.chainId], ethers_1.ethers.utils.parseUnits((0, conversion_1.formatAmount)(token1Amount.toString(), token1.decimals), token1.decimals), token1.address.toLowerCase() === constants_1.WETH[this.chainId].address.toLowerCase(), gasPrice);
            const positionToIncreaseBy = yield this.constructPosition(sdk_core_1.CurrencyAmount.fromRawAmount(token0, (0, conversion_1.fromReadableAmount)(Number((0, conversion_1.formatAmount)(token0Amount.toString(), token0.decimals)), token0.decimals)), sdk_core_1.CurrencyAmount.fromRawAmount(token1, (0, conversion_1.fromReadableAmount)(Number((0, conversion_1.formatAmount)(token1Amount.toString(), token1.decimals)), token1.decimals)), pool.pool, positionInfo.tickLower, positionInfo.tickUpper);
            const addLiquidityOptions = {
                deadline: Math.floor(Date.now() / 1000) + 60 * 20,
                slippageTolerance: new sdk_core_1.Percent(50, 10000),
                tokenId: positionId,
            };
            // get calldata for increasing a position
            const payload = warp_v3_sdk_1.NonfungiblePositionManager.addCallParameters(positionToIncreaseBy, addLiquidityOptions);
            return payload;
        });
    }
    /**
     * Retrieves the token transfer approval for a given token and spender address.
     * If the token is WETH or `approveWeth` is set to true, it approves the spender address to spend the maximum amount of tokens.
     * Otherwise, it checks if the current allowance is already enough and if not, approves the spender address to spend the maximum amount of tokens.
     * @param token The token for which to retrieve the transfer approval.
     * @param spenderAddress The address of the spender.
     * @param amount The amount of tokens to approve. Defaults to `ethers.constants.MaxUint256`.
     * @param approveWeth Whether to approve the spender address for WETH token. Defaults to `false`.
     * @returns A promise that resolves to the transaction receipt once the approval is complete.
     * @throws Error if there is no provider or address.
     */
    getTokenTransferApproval(token, spenderAddress, amount = ethers_1.ethers.constants.MaxUint256, approveWeth = false, gasPrice) {
        return __awaiter(this, void 0, void 0, function* () {
            if (approveWeth || token.address != constants_1.WETH[this.chainId].address) {
                const provider = this.signer.provider;
                const address = yield this.signer.getAddress();
                if (!provider || !address) {
                    throw Error("No provider or address");
                }
                try {
                    const tokenContract = new ethers_1.ethers.Contract(token.address, constants_1.ERC20_ABI, provider);
                    // Check if the allowance is already enough
                    const allowance = yield tokenContract.allowance(address, spenderAddress);
                    if (allowance.gte(amount)) {
                        return;
                    }
                    const transaction = yield tokenContract
                        .connect(this.signer)
                        .approve(spenderAddress, ethers_1.ethers.constants.MaxUint256, {
                        maxFeePerGas: constants_1.MAX_FEE_PER_GAS[this.chainId],
                        maxPriorityFeePerGas: constants_1.MAX_PRIORITY_FEE_PER_GAS[this.chainId],
                        gasPrice: gasPrice,
                    });
                    return transaction.wait();
                }
                catch (e) {
                    throw e;
                }
            }
        });
    }
    /**
     * Constructs a position using the provided token amounts, pool configuration, and tick range.
     * @param token0Amount The amount of token0.
     * @param token1Amount The amount of token1.
     * @param configuredPool The configured pool.
     * @param tickLower The lower tick of the position.
     * @param tickUpper The upper tick of the position.
     * @returns A Promise that resolves to the constructed Position.
     * @throws Error if no provider is available.
     */
    constructPosition(token0Amount, token1Amount, configuredPool, tickLower, tickUpper) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.signer.provider) {
                throw new Error("No provider");
            }
            // create position using the maximum liquidity from input amounts
            return warp_v3_sdk_1.Position.fromAmounts({
                pool: configuredPool,
                // tickLower: -TICK_SPACINGS[fee],
                // tickUpper: TICK_SPACINGS[fee],
                tickLower,
                tickUpper,
                amount0: token0Amount.quotient,
                amount1: token1Amount.quotient,
                useFullPrecision: true,
            });
        });
    }
    /**
     * Performs a swap between two tokens.
     *
     * @param tokenIn The input token.
     * @param tokenOut The output token.
     * @param tradeType The type of trade.
     * @param tokenAmount The amount of tokens to swap.
     * @param options Additional swap options.
     * @returns The swap transaction.
     * @throws Error if the slippage tolerance is invalid or the deadline is in the past.
     */
    swap(tokenIn, tokenOut, tradeType, tokenAmount, options, gasPrice) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (options.slippage &&
                (typeof options.slippage !== "number" ||
                    (options.slippage > 0 && options.slippage < 0))) {
                throw Error("Slippage tolerance between 0 to 100");
            }
            if (options.deadline &&
                (typeof options.deadline !== "number" ||
                    options.deadline < Date.now() / 1000 + 60)) {
                throw Error("Deadline should not be of past value");
            }
            let tokenInput = tokenIn;
            let tokenOutput = tokenOut;
            if (tokenIn.address.toLowerCase() == constants_1.WETH[this.chainId].address.toLowerCase()) {
                tokenInput = ether_1.Ether.onChain(this.chainId);
            }
            if (tokenOut.address.toLowerCase() == constants_1.WETH[this.chainId].address.toLowerCase()) {
                tokenOutput = ether_1.Ether.onChain(this.chainId);
            }
            const amount = tradeType == sdk_core_1.TradeType.EXACT_INPUT
                ? (0, warp_smart_order_router_1.parseAmount)((0, conversion_1.formatAmount)(tokenAmount, tokenInput.decimals), tokenInput)
                : (0, warp_smart_order_router_1.parseAmount)((0, conversion_1.formatAmount)(tokenAmount, tokenOutput.decimals), tokenOutput);
            const provider = new ethers_1.ethers.providers.JsonRpcProvider(constants_1.RPC_URL[this.chainId]);
            const router = new warp_smart_order_router_1.AlphaRouter({
                chainId: this.chainId,
                provider: provider,
            });
            if (!tokenInput.isNative) {
                yield this.getTokenTransferApproval(tokenIn, constants_1.SMART_ROUTER_ADDRESS[this.chainId], ethers_1.ethers.utils.parseUnits(tokenAmount.toString(), tokenIn.decimals), false, gasPrice);
            }
            const swap = yield router.route(amount, this.getQuoteToken(tokenInput, tokenOutput, tradeType), tradeType, {
                type: warp_smart_order_router_1.SwapType.SWAP_ROUTER_02,
                slippageTolerance: new sdk_core_1.Percent(Math.floor(((_a = options === null || options === void 0 ? void 0 : options.slippage) !== null && _a !== void 0 ? _a : 0.5) * 10000), 10000),
                recipient: yield this.signer.getAddress(),
                deadline: (options === null || options === void 0 ? void 0 : options.deadline)
                    ? Math.floor(options.deadline)
                    : Math.floor(Date.now() / 1000) + 60 * 20,
            }, Object.assign({ protocols: [router_sdk_1.Protocol.V3] }, (this.chainId === constants_1.ChainId.MOVEMENT_TESTNET
                ? { distributionPercent: 100 }
                : {})));
            return swap;
        });
    }
    /**
     * Retrieves a quote for a trade between two tokens.
     * @param tokenIn The input token for the trade.
     * @param tokenOut The output token for the trade.
     * @param tradeType The type of trade (exact input or exact output).
     * @param tokenAmount The amount of tokens to be traded.
     * @param slippage The maximum acceptable slippage for the trade.
     * @returns An object containing the exchange rate, price impact, and route of the trade.
     */
    getQuote(tokenIn, tokenOut, tradeType, tokenAmount, slippage) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            let tokenInput = tokenIn;
            let tokenOutput = tokenOut;
            if (tokenIn.address == constants_1.WETH[this.chainId].address) {
                tokenInput = ether_1.Ether.onChain(this.chainId);
            }
            if (tokenOut.address == constants_1.WETH[this.chainId].address) {
                tokenOutput = ether_1.Ether.onChain(this.chainId);
            }
            const slippagePercent = new sdk_core_1.Percent(Math.floor((slippage !== null && slippage !== void 0 ? slippage : 0.5) * 10000), 10000);
            const amount = tradeType == sdk_core_1.TradeType.EXACT_INPUT
                ? (0, warp_smart_order_router_1.parseAmount)((0, conversion_1.formatAmount)(tokenAmount, tokenInput.decimals), tokenInput)
                : (0, warp_smart_order_router_1.parseAmount)((0, conversion_1.formatAmount)(tokenAmount, tokenOutput.decimals), tokenOutput);
            const provider = new ethers_1.ethers.providers.JsonRpcProvider(constants_1.RPC_URL[this.chainId]);
            const router = new warp_smart_order_router_1.AlphaRouter({
                chainId: this.chainId,
                provider: provider,
            });
            const swap = yield router.route(amount, this.getQuoteToken(tokenInput, tokenOutput, tradeType), tradeType, {
                type: warp_smart_order_router_1.SwapType.SWAP_ROUTER_02,
                slippageTolerance: slippagePercent,
                recipient: yield this.signer.getAddress(),
                deadline: Math.floor(Date.now() / 1000) + 60 * 20,
            }, Object.assign({ protocols: [router_sdk_1.Protocol.V3] }, (this.chainId === constants_1.ChainId.MOVEMENT_TESTNET
                ? { distributionPercent: 100 }
                : {})));
            const exchangeRate = tradeType == sdk_core_1.TradeType.EXACT_INPUT
                ? (_b = (_a = swap === null || swap === void 0 ? void 0 : swap.trade) === null || _a === void 0 ? void 0 : _a.executionPrice) === null || _b === void 0 ? void 0 : _b.toSignificant()
                : (_e = (_d = (_c = swap === null || swap === void 0 ? void 0 : swap.trade) === null || _c === void 0 ? void 0 : _c.executionPrice) === null || _d === void 0 ? void 0 : _d.invert()) === null || _e === void 0 ? void 0 : _e.toSignificant();
            const priceImpact = swap.trade.priceImpact.toSignificant();
            const route = swap.trade.routes;
            return {
                exchangeRate,
                priceImpact,
                route,
            };
        });
    }
    /**
     * Constructs a position with placeholder liquidity.
     *
     * @param token0 - The first token of the pool.
     * @param token1 - The second token of the pool.
     * @param poolFee - The fee amount of the pool.
     * @returns A promise that resolves to a Position object.
     */
    constructPositionWithPlaceholderLiquidity(token0, token1, poolFee) {
        return __awaiter(this, void 0, void 0, function* () {
            // get pool info
            const poolInfo = yield (0, pool_1.getPoolInfo)(token0, token1, poolFee, this.signer.provider, this.chainId);
            // construct pool instance
            const configuredPool = new warp_v3_sdk_1.Pool(token0, token1, poolInfo.fee, poolInfo.sqrtPriceX96.toString(), poolInfo.liquidity.toString(), poolInfo.tick);
            // create position using the maximum liquidity from input amounts
            return new warp_v3_sdk_1.Position({
                pool: configuredPool,
                tickLower: (0, warp_v3_sdk_1.nearestUsableTick)(poolInfo.tick, poolInfo.tickSpacing) -
                    poolInfo.tickSpacing * 2,
                tickUpper: (0, warp_v3_sdk_1.nearestUsableTick)(poolInfo.tick, poolInfo.tickSpacing) +
                    poolInfo.tickSpacing * 2,
                liquidity: 1,
            });
        });
    }
    /**
     * Collects fees for a given position.
     * @param positionId - The ID of the position.
     * @param token0 - The first token of the position.
     * @param token1 - The second token of the position.
     * @param recipient - The address where the collected fees will be sent to.
     * @returns A promise that resolves to the method parameters for collecting fees.
     */
    collectFees(positionId, token0, token1, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const collectOptions = {
                tokenId: positionId,
                expectedCurrencyOwed0: sdk_core_1.CurrencyAmount.fromRawAmount(token0, 0),
                expectedCurrencyOwed1: sdk_core_1.CurrencyAmount.fromRawAmount(token1, 0),
                recipient,
            };
            // get calldata for minting a position
            const payload = warp_v3_sdk_1.NonfungiblePositionManager.collectCallParameters(collectOptions);
            return payload;
        });
    }
    /**
     * Removes liquidity from a position.
     *
     * @param positionId - The ID of the position.
     * @param token0 - The first token in the liquidity pair.
     * @param token1 - The second token in the liquidity pair.
     * @param percent - The percentage of liquidity to remove.
     * @param recipient - The address where the removed liquidity will be sent.
     * @returns A Promise that resolves to the method parameters for removing liquidity.
     */
    removeLiquidity(positionId, token0, token1, percent, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const positionInfo = yield this.getPositionInfo(positionId);
            const currencyAmount0 = sdk_core_1.CurrencyAmount.fromRawAmount(token0, new bignumber_js_1.default(positionInfo.tokenAmount0.toString())
                .multipliedBy(new bignumber_js_1.default(10).pow(token0.decimals))
                .toFixed());
            const currencyAmount1 = sdk_core_1.CurrencyAmount.fromRawAmount(token1, new bignumber_js_1.default(positionInfo.tokenAmount1.toString())
                .multipliedBy(new bignumber_js_1.default(10).pow(token1.decimals))
                .toFixed());
            const poolInfo = yield (0, pool_1.getPoolInfo)(currencyAmount0.currency, currencyAmount1.currency, positionInfo.fee, this.signer.provider, this.chainId);
            const pool = new warp_v3_sdk_1.Pool(currencyAmount0.currency, currencyAmount1.currency, poolInfo.fee, poolInfo.sqrtPriceX96.toString(), Number(poolInfo.liquidity.toString()) === 0
                ? positionInfo.liquidity.toString()
                : poolInfo.liquidity.toString(), poolInfo.tick);
            const currentPosition = yield this.constructPosition(currencyAmount0, currencyAmount1, pool, positionInfo.tickLower, positionInfo.tickUpper);
            const collectOptions = {
                expectedCurrencyOwed0: sdk_core_1.CurrencyAmount.fromRawAmount(token0, 0),
                expectedCurrencyOwed1: sdk_core_1.CurrencyAmount.fromRawAmount(token1, 0),
                recipient,
            };
            const removeLiquidityOptions = {
                deadline: Math.floor(Date.now() / 1000) + 60 * 20,
                slippageTolerance: new sdk_core_1.Percent(50, 10000),
                tokenId: positionId,
                // percentage of liquidity to remove
                liquidityPercentage: new sdk_core_1.Percent(Math.floor(percent * 10000), 10000),
                collectOptions,
            };
            // get calldata for minting a position
            const payload = warp_v3_sdk_1.NonfungiblePositionManager.removeCallParameters(currentPosition, removeLiquidityOptions);
            return payload;
        });
    }
    /**
     * Wraps the native token by depositing the specified amount into the WETH contract.
     * @param amount - The amount of native token to wrap.
     * @returns A promise that resolves to the transaction object.
     */
    wrapNativeToken(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const wethContract = new ethers_1.ethers.Contract(constants_1.WETH[this.chainId].address, constants_1.WETH_ABI, this.signer);
            const tx = yield wethContract.deposit({
                value: ethers_1.ethers.utils.parseEther((0, conversion_1.formatAmount)(amount, 18)),
                maxFeePerGas: constants_1.MAX_FEE_PER_GAS[this.chainId],
                maxPriorityFeePerGas: constants_1.MAX_PRIORITY_FEE_PER_GAS[this.chainId],
            });
            return tx;
        });
    }
    /**
     * Unwraps the native token by withdrawing the specified amount from the WETH contract.
     * @param amount - The amount of native token to unwrap.
     * @returns A promise that resolves to the transaction object.
     */
    unwrapNativeToken(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const wethContract = new ethers_1.ethers.Contract(constants_1.WETH[this.chainId].address, constants_1.WETH_ABI, this.signer);
            const tx = yield wethContract.withdraw(ethers_1.ethers.utils.parseEther((0, conversion_1.formatAmount)(amount, 18)), {
                maxFeePerGas: constants_1.MAX_FEE_PER_GAS[this.chainId],
                maxPriorityFeePerGas: constants_1.MAX_PRIORITY_FEE_PER_GAS[this.chainId],
            });
            return tx;
        });
    }
}
exports.liquidityClient = liquidityClient;
