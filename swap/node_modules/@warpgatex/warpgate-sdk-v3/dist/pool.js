"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeTokenAmountForLiquidity = exports.getPoolData = exports.getPoolInfo = void 0;
const ethers_1 = require("ethers");
const IUniswapV3Pool_json_1 = __importDefault(require("@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json"));
const constants_1 = require("./constants");
const warp_v3_sdk_1 = require("@warpgatex/warp-v3-sdk");
const warp_v3_sdk_2 = require("@warpgatex/warp-v3-sdk");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
/**
 * Retrieves information about a pool.
 * @param tokenA - The first token in the pool.
 * @param tokenB - The second token in the pool.
 * @param poolFee - The fee amount for the pool.
 * @param provider - The Ethereum provider.
 * @param chainId - The chain ID.
 * @returns A Promise that resolves to the pool information or null if the pool does not exist.
 * @throws An error if no provider is provided.
 */
function getPoolInfo(tokenA, tokenB, poolFee, provider, chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!provider) {
            throw new Error("No provider");
        }
        if (!Object.values(constants_1.ChainId).includes(Number(chainId))) {
            throw new Error("Invalid Chain ID");
        }
        const currentPoolAddress = (0, warp_v3_sdk_1.computePoolAddress)({
            factoryAddress: constants_1.DEPLOYER_ADDRESS[chainId],
            tokenA: tokenA,
            tokenB: tokenB,
            fee: poolFee,
            initCodeHashManualOverride: constants_1.POOL_INIT_CODE_HASH[chainId],
        });
        console.log("currentPoolAddress: ", currentPoolAddress);
        //check if current pool exists
        const code = yield provider.getCode(currentPoolAddress);
        if (code === "0x") {
            return null;
        }
        const poolContract = new ethers_1.ethers.Contract(currentPoolAddress, IUniswapV3Pool_json_1.default.abi, provider);
        const [token0, token1, fee, tickSpacing, liquidity, slot0] = yield Promise.all([
            poolContract.token0(),
            poolContract.token1(),
            poolContract.fee(),
            poolContract.tickSpacing(),
            poolContract.liquidity(),
            poolContract.slot0(),
        ]);
        const currentTick = slot0[1];
        const currentPrice = tokenA.address == token0
            ? 1.0001 ** currentTick * 10 ** (tokenA.decimals - tokenB.decimals)
            : 1.0001 ** -currentTick * 10 ** (tokenA.decimals - tokenB.decimals);
        return {
            token0,
            token1,
            fee,
            tickSpacing,
            liquidity,
            sqrtPriceX96: slot0[0],
            tick: slot0[1],
            currentPrice,
        };
    });
}
exports.getPoolInfo = getPoolInfo;
/**
 * Retrieves the pool data for a given pair of tokens and pool fee.
 * If the pool does not exist, it creates a new pool with the provided tokens and fee.
 *
 * @param token0 - The first token in the pair.
 * @param token1 - The second token in the pair.
 * @param poolFee - The fee amount for the pool.
 * @param provider - The ethers provider used to interact with the blockchain.
 * @param chainId - The chain ID.
 * @returns An object containing the pool data and a flag indicating whether the pool was created.
 * @throws If there is an error retrieving or creating the pool.
 */
function getPoolData(token0, token1, poolFee, provider, chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Object.values(constants_1.ChainId).includes(Number(chainId))) {
            throw new Error("Invalid Chain ID");
        }
        try {
            const poolInfo = yield getPoolInfo(token0.currency, token1.currency, poolFee, provider, chainId);
            let pool;
            if (!poolInfo) {
                const currentTick = warp_v3_sdk_2.TickMath.getTickAtSqrtRatio((0, warp_v3_sdk_1.encodeSqrtRatioX96)(token1.quotient, token0.quotient));
                pool = new warp_v3_sdk_1.Pool(token0.currency, token1.currency, poolFee, (0, warp_v3_sdk_1.encodeSqrtRatioX96)(token1.quotient, token0.quotient).toString(), "0", currentTick);
                return { pool, createPool: true };
            }
            else {
                pool = new warp_v3_sdk_1.Pool(token0.currency, token1.currency, poolInfo.fee, poolInfo.sqrtPriceX96.toString(), poolInfo.liquidity.toString(), poolInfo.tick);
                return { pool, createPool: false };
            }
        }
        catch (err) {
            console.debug(err);
            throw err;
        }
    });
}
exports.getPoolData = getPoolData;
/**
 * Computes the token amount for liquidity based on the given parameters.
 *
 * @param token0 - The first token in the pool.
 * @param token1 - The second token in the pool.
 * @param amount - The amount of liquidity.
 * @param poolFee - The fee amount for the pool.
 * @param currentPrice - The current price of the pool.
 * @param output - The desired output token ("token0" or "token1").
 * @param lowerPrice - The lower price limit.
 * @param upperPrice - The upper price limit.
 * @returns The computed output amount.
 */
const computeTokenAmountForLiquidity = (token0, token1, amount, poolFee, currentPrice, output = "token0", lowerPrice, upperPrice) => {
    const currentTick = (0, warp_v3_sdk_1.nearestUsableTick)(Math.floor(Math.log(currentPrice) / Math.log(1.0001)), warp_v3_sdk_1.TICK_SPACINGS[poolFee]);
    let tickLower;
    let tickUpper;
    if (lowerPrice) {
        const priceTick = Math.floor(Math.log(lowerPrice) / Math.log(1.0001));
        tickLower = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[poolFee]);
    }
    else {
        tickLower = (0, warp_v3_sdk_1.nearestUsableTick)(warp_v3_sdk_2.TickMath.MIN_TICK, warp_v3_sdk_1.TICK_SPACINGS[poolFee]);
    }
    if (upperPrice) {
        const priceTick = Math.floor(Math.log(upperPrice) / Math.log(1.0001));
        tickUpper = (0, warp_v3_sdk_1.nearestUsableTick)(priceTick, warp_v3_sdk_1.TICK_SPACINGS[poolFee]);
    }
    else {
        tickUpper = (0, warp_v3_sdk_1.nearestUsableTick)(warp_v3_sdk_2.TickMath.MAX_TICK, warp_v3_sdk_1.TICK_SPACINGS[poolFee]);
    }
    const pool = new warp_v3_sdk_1.Pool(token0, token1, poolFee, warp_v3_sdk_2.TickMath.getSqrtRatioAtTick(currentTick), "0", currentTick);
    const amountReq = new bignumber_js_1.default(amount)
        .multipliedBy(new bignumber_js_1.default(10).pow((output === "token0" ? token1 : token0).decimals))
        .toFixed();
    const position = output === "token1"
        ? warp_v3_sdk_1.Position.fromAmount0({
            pool,
            tickLower,
            tickUpper,
            amount0: amountReq,
            useFullPrecision: true,
        })
        : warp_v3_sdk_1.Position.fromAmount1({
            pool,
            tickLower,
            tickUpper,
            amount1: amountReq,
        });
    const outputAmount = output === "token0"
        ? position.amount0.toFixed()
        : position.amount1.toFixed();
    return outputAmount;
};
exports.computeTokenAmountForLiquidity = computeTokenAmountForLiquidity;
